<!DOCTYPE html>
<!-- 
    Tradwife Trend Analysis Page
    This page visualizes data about the "tradwife" trend on social media platforms,
    including video uploads, views, and engagement metrics over different time periods
-->
<html lang="de" class="light">
<head>
    <!-- Meta tags for character encoding and responsive design -->
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Tradwife Trend Analysis</title>

    <!-- External libraries and frameworks -->
    <script src="https://cdn.tailwindcss.com" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.canvasjs.com/canvasjs.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"/>

    <!-- Custom styles -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
    <link rel="icon" type="image/png" href="{{ url_for('favicon') }}">
</head>
<body class="min-h-screen bg-gradient-to-br from-indigo-50 to-blue-100 text-gray-900">
<!-- Dark mode toggle button in the corner of the page -->
{% include 'partials/dark_mode_toggle.html' %}

<!-- Set the page title for the header component -->
{% set page_title = 'Tradwife Trend Analysis' %}
{% include 'partials/page_header.html' %}

<!-- 
    Introduction Section
    Explains what the "tradwife" trend is and provides context
-->
<section class="max-w-7xl mx-auto mt-4 bg-white rounded-2xl shadow p-6 space-y-3">
    <h2 class="text-xl font-semibold">What is "Tradwife"?</h2>
    <p class="text-gray-700">In 2020, the term "tradwife" started appearing on social media and has gained notable traction in the last two years. A "tradwife" is a woman who embraces traditional gender roles and relationships, often preferring to focus on caring for the household and family rather than pursuing a career.</p>
    <p class="text-gray-700">On social media, creators who embody this lifestyle often show themselves cooking, cleaning, or caring for their families. The trend sometimes romanticizes traditional gender roles and relationships, which is why it has also faced considerable criticism.</p>
</section>

<!-- 
    Analysis Overview Section
    Summarizes the methodology and key findings of the data analysis
-->
<section class="max-w-7xl mx-auto mt-4 bg-white rounded-2xl shadow mb-6 p-6 space-y-3">
    <h2 class="text-xl font-semibold">What did we analyze?</h2>
    <p class="text-gray-700">This analysis explores how the "tradwife" culture has developed on YouTube over time. Using the YouTube Data API, we collected the number of videos, views, and likes across specific time periods.</p>
    <h3 class="font-medium">Key findings</h3>
    <ul class="list-disc pl-6 text-gray-700 space-y-1">
        <li>The number of videos and total views began increasing in 2023 and continues to rise.</li>
        <li>The ratio of likes to views peaked in 2023, then decreased until April 2025. Since then, the ratio has started to increase again.</li>
    </ul>
</section>

<div class="max-w-7xl mx-auto">
    <!-- 
        Filter Controls Section
        Allows users to filter data by year and select which metrics to display
    -->
    <div class="flex items-center gap-3 flex-wrap justify-center mb-6">
        <label class="font-medium">Year:</label>
        <select id="year-selector" class="border rounded p-2 bg-white">
            <option value="all">Every year</option>
            <option value="2024">2024</option>
            <option value="2025">2025</option>
            <option value="detailed">Detailed</option>
        </select>

        <label for="metricsDropdown" class="font-medium">Metrics:</label>
        <div class="relative inline-block">
            <button id="metricsDropdown" type="button"
                    class="border rounded p-2 bg-white flex items-center justify-between min-w-[150px] metrics-dropdown-button">
                <span>All Metrics</span>
                <svg class="w-4 h-4 ml-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                     xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                </svg>
            </button>
            <div id="metricsDropdownContent"
                 class="absolute z-10 hidden bg-white border mt-1 metrics-dropdown-content max-h-60 overflow-y-auto min-w-[200px]">
                <div class="p-2 border-b">
                    <label class="flex items-center cursor-pointer">
                        <input type="checkbox" id="selectAllMetrics" class="mr-2 custom-checkbox" checked>
                        <span>Select all</span>
                    </label>
                </div>
                <div id="metricsCheckboxes" class="p-2">
                    <div class="metrics-checkbox-container">
                        <label class="flex items-center cursor-pointer w-full">
                            <input type="checkbox" value="videos" class="mr-2 metric-checkbox custom-checkbox" checked>
                            <span>Videos</span>
                        </label>
                    </div>
                    <div class="metrics-checkbox-container">
                        <label class="flex items-center cursor-pointer w-full">
                            <input type="checkbox" value="views" class="mr-2 metric-checkbox custom-checkbox" checked>
                            <span>Views</span>
                        </label>
                    </div>
                    <div class="metrics-checkbox-container">
                        <label class="flex items-center cursor-pointer w-full">
                            <input type="checkbox" value="likes" class="mr-2 metric-checkbox custom-checkbox" checked>
                            <span>Likes</span>
                        </label>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Subtitle under filters and above chart -->
    <div id="subtitle" class="text-sm my-5 text-center"></div>

    <!-- 
        Data Table Section
        Displays detailed metrics in a sortable table format
    -->
    <div class="overflow-x-auto shadow rounded-2xl mb-8 bg-white">
        <table id="tradwifeTable" class="min-w-full border-collapse">
            <thead>
            <tr class="bg-gray-100 text-left" id="tableHead"></tr>
            </thead>
            <tbody></tbody>
            <tfoot id="tableFoot"></tfoot>
        </table>
    </div>

    <!-- 
        Data Visualization Section - Line Chart
        Shows trends of selected metrics over time
    -->
    <section>
        <!-- Combined Line Chart -->
        <div class="overflow-x-auto shadow rounded-2xl mb-8 bg-white">
            <div id="combinedChartTitle" class="mb-3 text-xl font-bold text-center pt-4" style="display: none;"></div>
            <div class="chart-container"
                 style="position: relative; height: 35vh; min-height: 300px; max-height: 600px; width: 100%; padding: 0 16px 16px;">
                <canvas id="combinedChart"></canvas>
            </div>
        </div>
    </section>

    <!-- 
        Data Visualization Section - Bubble Chart
        Shows relationship between likes, time, videos count, and views
    -->
    <section>
        <div class="overflow-x-auto shadow rounded-2xl mb-8 bg-white">
            <div class="mb-3 text-xl font-bold text-center pt-4">Bubble Chart: Likes √ºber Zeit (Gr√∂√üe = Videos, Farbe = Views)</div>
            <div id="bubbleChartContainer" style="height: 420px; width: 100%;"></div>
        </div>
    </section>

    <!-- 
        Data Visualization Section - Pie Charts
        Shows distribution of metrics across time periods
    -->
    <section class="mt-8 grid gap-8 lg:grid-cols-3">
        <!-- Videos Pie Chart (hidden by default) -->
        <div id="videosPieContainer" class="max-w-xl hidden">
            <div class="mb-2 font-semibold">Distribution of Videos</div>
            <canvas id="videosPieChart"></canvas>
        </div>

        <!-- Views Pie Chart (hidden by default) -->
        <div id="viewsPieContainer" class="max-w-xl hidden">
            <div class="mb-2 font-semibold">Distribution of Views</div>
            <canvas id="viewsPieChart"></canvas>
        </div>

        <!-- Likes Pie Chart (hidden by default) -->
        <div id="likesPieContainer" class="max-w-xl hidden">
            <div class="mb-2 font-semibold">Distribution of Likes</div>
            <canvas id="likesPieChart"></canvas>
        </div>
    </section>

    <!-- 
        Information Cards Section
        Provides additional context about the tradwife trend and analysis
    -->
    <section class="grid sm:grid-cols-2 lg:grid-cols-3 gap-6 mt-12">
        <div class="block rounded-2xl bg-white shadow p-6">
            <h2 class="text-xl font-bold text-pink-700 mb-2">üìπ What is Tradwife?</h2>
            <p class="text-gray-600">The "tradwife" (traditional wife) movement promotes traditional gender roles and
                homemaking.</p>
        </div>

        <div class="block rounded-2xl bg-white shadow p-6">
            <h2 class="text-xl font-bold text-pink-700 mb-2">üìä Data Analysis</h2>
            <p class="text-gray-600">This page analyzes the growth of tradwife content on social media platforms over
                time.</p>
        </div>

        <div class="block rounded-2xl bg-white shadow p-6">
            <h2 class="text-xl font-bold text-pink-700 mb-2">üîç Methodology</h2>
            <p class="text-gray-600">Data collected from social media platforms tracking videos, views, and engagement
                metrics.</p>
        </div>
    </section>
</div>

<script defer>
    /**
     * Main JavaScript for Tradwife data visualization
     * Handles data loading, chart rendering, and interactive filters
     */

    // Custom plugin to add tooltips to legend items
    const legendTooltipPlugin = {
        id: 'legendTooltip',
        afterRender: function (chart) {
            // Use setTimeout to ensure the legend is fully rendered
            setTimeout(() => {
                // Find the legend container
                const legendContainer = chart.canvas.parentNode.querySelector('ul.legend-items') ||
                    chart.canvas.parentNode.querySelector('.chart-legend') ||
                    chart.canvas.parentNode.querySelector('ul');

                if (legendContainer) {
                    // Get all list items in the legend
                    const legendItems = legendContainer.querySelectorAll('li');

                    // Add tooltip to legend items for videos, views, and likes
                    legendItems.forEach(item => {
                        const text = item.textContent.trim();
                        if (text.includes('Videos') || text.includes('Views') || text.includes('Likes')) {
                            // Add the metric-legend-item class
                            item.classList.add('metric-legend-item');

                            // Find the color box within the legend item
                            const colorBox = item.querySelector('span') || item.querySelector('div');
                            if (colorBox) {
                                colorBox.classList.add('metric-legend-item');
                            }
                        }
                    });
                }
            }, 100); // Small delay to ensure DOM is updated
        }
    };

    // Data storage for different views (all years, detailed, and individual years)
    let dataStore = {
        all: [],
        detailed: [],
        "2020": [],
        "2021": [],
        "2022": [],
        "2023": [],
        "2024": [],
        "2025": []
    };

    // State variables for the current view and charts
    let currentView = "all";
    let combinedChart, videosPieChart, viewsPieChart, likesPieChart, bubbleChart;
    let sortState = {key: null, dir: 1};
    let selectedMetrics = ["videos", "views", "likes"];

    /**
     * Color schemes for visualization
     * Consistent colors help users identify time periods and metrics across charts
     */
    // Time Period Colors - purple to green gradient for years
    const PERIOD_COLORS = new Map([
        ["2020", "#8B5CF6"],
        ["2021", "#6366F1"],
        ["2022", "#3B82F6"],
        ["2023", "#0EA5E9"],
        ["2024", "#06B6D4"],
        ["2025", "#22C55E"]
    ]);

    // Metrics Colors - distinct colors for different metrics
    const METRICS_COLORS = {
        videos: "#FF6B6B",  // Red
        views: "#4ECDC4",   // Teal
        likes: "#FFD166"    // Yellow
    };

    /**
     * Helper functions for data formatting and display
     */
    // Format period strings for display (e.g., "2024_first_third" -> "2024 (Jan-Apr)")
    const prettyPeriod = (period) => {
        if (period.includes("_first_third")) return period.split("_")[0] + " (Jan-Apr)";
        if (period.includes("_second_third")) return period.split("_")[0] + " (May-Aug)";
        if (period.includes("_third_third")) return period.split("_")[0] + " (Sep-Dec)";
        return period;
    };

    // Get color for a time period from the color map
    const getPeriodColor = (period) => PERIOD_COLORS.get(period) || "#9CA3AF";

    // Format large numbers with commas for better readability
    const formatNumber = (num) => num.toLocaleString("de-DE");

    /**
     * DATA LOADING AND PROCESSING
     * Fetches data from JSON file, processes it into different views (all, detailed, yearly),
     * and calculates derived metrics
     */
    fetch("/answer_seven.json")
        .then(response => {
            if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
            return response.json();
        })
        .then(data => {
            // Initialize data arrays for different views
            const allData = [];
            const detailedData = [];
            const yearData = {
                "2020": [],
                "2021": [],
                "2022": [],
                "2023": [],
                "2024": [],
                "2025": []
            };

            // Temporary storage for calculating 2024 and 2025 aggregates
            const year2024Data = {
                periods: 0,
                videos: 0,
                views: 0,
                likes: 0
            };

            const year2025Data = {
                periods: 0,
                videos: 0,
                views: 0,
                likes: 0
            };

            // Process each time period in the data
            Object.entries(data).forEach(([period, stats]) => {
                // Create data point with raw and calculated metrics
                const dataPoint = {
                    period: period,
                    prettyPeriod: prettyPeriod(period),
                    videos: stats.videos,
                    views: stats.views,
                    likes: stats.likes,
                    viewsPerVideo: Math.round(stats.views / stats.videos),
                    likesPerVideo: Math.round(stats.likes / stats.videos),
                    likesPerView: ((stats.likes / stats.views) * 100).toFixed(2)
                };

                // For detailed view, include all periods
                detailedData.push(dataPoint);

                // Aggregate data for 2024 and 2025 
                if (period.startsWith("2024_")) {
                    year2024Data.periods++;
                    year2024Data.videos += stats.videos;
                    year2024Data.views += stats.views;
                    year2024Data.likes += stats.likes;
                } else if (period.startsWith("2025_")) {
                    year2025Data.periods++;
                    year2025Data.videos += stats.videos;
                    year2025Data.views += stats.views;
                    year2025Data.likes += stats.likes;
                }

                // For all data view, include full years (except 2024 and 2025 which will be added as aggregates later)
                if (!period.includes("_") && period !== "2024" && period !== "2025") {
                    allData.push(dataPoint);
                }

                // Add to respective year arrays
                if (!period.includes("_")) {
                    yearData[period].push(dataPoint);
                }
                // For periods with year prefix (e.g., 2024_first_third), add to respective year arrays
                else {
                    const year = period.split("_")[0];
                    if (yearData[year]) {
                        yearData[year].push(dataPoint);
                    }
                }
            });

            // Add aggregate data points for 2024 and 2025 to allData
            // Note: Commented code below was part of an earlier implementation
            // if (year2024Data.periods > 0) {
            //    allData.push({
            //        period: "2024",
            //        prettyPeriod: "2024",
            //        videos: year2024Data.videos,
            //        views: year2024Data.views,
            //        likes: year2024Data.likes,
            //        viewsPerVideo: Math.round(year2024Data.views / year2024Data.videos),
            //        likesPerVideo: Math.round(year2024Data.likes / year2024Data.videos),
            //        likesPerView: ((year2024Data.likes / year2024Data.views) * 100).toFixed(2)
            //    });
            // }

            // Add aggregate data points for 2024 to allData
            if (year2024Data.periods > 0) {
              allData.push({
                period: "2024",
                prettyPeriod: "2024",
                videos: Math.round(year2024Data.videos),
                views: Math.round(year2024Data.views),
                likes: Math.round(year2024Data.likes),
                viewsPerVideo: Math.round((year2024Data.views) / (year2024Data.videos)),
                likesPerVideo: Math.round((year2024Data.likes) / (year2024Data.videos)),
                likesPerView: (((year2024Data.likes) / (year2024Data.views)) * 100).toFixed(2)
              });
            }

            // Add aggregate data points for 2025 to allData
            if (year2025Data.periods > 0) {
              allData.push({
                period: "2025",
                prettyPeriod: "2025",
                videos: Math.round(year2025Data.videos),
                views: Math.round(year2025Data.views),
                likes: Math.round(year2025Data.likes),
                viewsPerVideo: Math.round((year2025Data.views) / (year2025Data.videos)),
                likesPerVideo: Math.round((year2025Data.likes) / (year2025Data.videos)),
                likesPerView: (((year2025Data.likes) / (year2025Data.views)) * 100).toFixed(2)
              });
            }

            // Store processed data in the dataStore object
            dataStore.all = allData;
            dataStore.detailed = detailedData;
            Object.keys(yearData).forEach(year => {
                dataStore[year] = yearData[year];
            });

            // Initialize visualization with the processed data
            refresh();
        })
        .catch(error => console.error("Error loading data:", error));

    /**
     * TABLE RENDERING FUNCTIONS
     * Creates and updates the data table with sortable columns
     */

    /**
     * Renders the table header with sortable columns
     * @param {Array} columns - Array of column definitions with key and label properties
     */
    function renderHeader(columns) {
        const thead = document.getElementById("tableHead");
        thead.innerHTML = "";
        columns.forEach(col => {
            const th = document.createElement("th");
            th.className = "px-4 py-2 border-b cursor-pointer select-none";
            th.dataset.sort = col.key;
            // Add sort indicators (‚ñ≤/‚ñº) to show current sort direction
            th.textContent = col.label + " " +
                (sortState.key === col.key ? (sortState.dir === 1 ? "‚ñ≤" : "‚ñº") : "‚ñ≤‚ñº");
            // Add click event for sorting
            th.addEventListener("click", () => {
                if (sortState.key === col.key) sortState.dir *= -1; // Toggle direction if same column
                else {
                    sortState.key = col.key; // Set new sort column
                    sortState.dir = 1;       // Default to ascending
                }
                refresh(); // Re-render with new sort
            });
            thead.appendChild(th);
        });
    }

    /**
     * Renders the complete data table with the provided dataset
     * Includes sortable columns, color-coded metrics, and totals row
     * @param {Array} data - Array of data objects to display in the table
     */
    function renderTable(data) {
        // Define table columns with keys and display labels
        const columns = [
            {key: "prettyPeriod", label: "Time Period"},
            {key: "videos", label: "Videos"},
            {key: "views", label: "Views"},
            {key: "likes", label: "Likes"},
            {key: "viewsPerVideo", label: "Views/Video"},
            {key: "likesPerVideo", label: "Likes/Video"},
            {key: "likesPerView", label: "Likes/View (%)"}
        ];

        // Render the table header with sortable columns
        renderHeader(columns);

        // Get references to table body and footer
        const tbody = document.querySelector("#tradwifeTable tbody");
        const tfoot = document.getElementById("tableFoot");
        tbody.innerHTML = "";
        tfoot.innerHTML = "";

        // Sort the data if a sort column is selected
        let tableData = data.slice();
        if (sortState.key) {
            tableData.sort((a, b) => {
                const va = a[sortState.key], vb = b[sortState.key];
                return (va < vb ? -1 : va > vb ? 1 : 0) * sortState.dir;
            });
        }

        // Track totals for summary row
        let totalVideos = 0, totalViews = 0, totalLikes = 0;

        // Create a row for each data point
        tableData.forEach(row => {
            // Accumulate totals
            totalVideos += row.videos;
            totalViews += row.views;
            totalLikes += row.likes;

            // Create table row with color-coded metrics
            const tr = document.createElement("tr");
            tr.className = "hover:bg-gray-50 transition-colors";
            tr.innerHTML = `
          <td class="px-4 py-2 border-b font-medium">
            <span class="inline-block w-3 h-3 rounded-sm align-middle mr-2"
                  style="background:${getPeriodColor(row.period)}"></span>
            ${row.prettyPeriod}
          </td>
          <td class="px-4 py-2 border-b">
            <span class="inline-flex items-center">
              <span class="inline-block w-3 h-3 rounded-sm align-middle mr-2 metric-legend-item"
                    style="background:${METRICS_COLORS.videos}"></span>
              ${formatNumber(row.videos)}
            </span>
          </td>
          <td class="px-4 py-2 border-b">
            <span class="inline-flex items-center">
              <span class="inline-block w-3 h-3 rounded-sm align-middle mr-2 metric-legend-item"
                    style="background:${METRICS_COLORS.views}"></span>
              ${formatNumber(row.views)}
            </span>
          </td>
          <td class="px-4 py-2 border-b">
            <span class="inline-flex items-center">
              <span class="inline-block w-3 h-3 rounded-sm align-middle mr-2 metric-legend-item"
                    style="background:${METRICS_COLORS.likes}"></span>
              ${formatNumber(row.likes)}
            </span>
          </td>
          <td class="px-4 py-2 border-b">${formatNumber(row.viewsPerVideo)}</td>
          <td class="px-4 py-2 border-b">${formatNumber(row.likesPerVideo)}</td>
          <td class="px-4 py-2 border-b">${row.likesPerView}%</td>
        `;
            tbody.appendChild(tr);
        });

        // Calculate averages for the summary row
        const avgViewsPerVideo = Math.round(totalViews / totalVideos);
        const avgLikesPerVideo = Math.round(totalLikes / totalVideos);
        const avgLikesPerView = ((totalLikes / totalViews) * 100).toFixed(2);

        // Add summary row with totals and averages
        tfoot.innerHTML = `
        <tr class="bg-gray-50 font-semibold">
          <td class="px-4 py-2 border-t">Total/Average</td>
          <td class="px-4 py-2 border-t">
            <span class="inline-flex items-center">
              <span class="inline-block w-3 h-3 rounded-sm align-middle mr-2 metric-legend-item"
                    style="background:${METRICS_COLORS.videos}"></span>
              ${formatNumber(totalVideos)}
            </span>
          </td>
          <td class="px-4 py-2 border-t">
            <span class="inline-flex items-center">
              <span class="inline-block w-3 h-3 rounded-sm align-middle mr-2 metric-legend-item"
                    style="background:${METRICS_COLORS.views}"></span>
              ${formatNumber(totalViews)}
            </span>
          </td>
          <td class="px-4 py-2 border-t">
            <span class="inline-flex items-center">
              <span class="inline-block w-3 h-3 rounded-sm align-middle mr-2 metric-legend-item"
                    style="background:${METRICS_COLORS.likes}"></span>
              ${formatNumber(totalLikes)}
            </span>
          </td>
          <td class="px-4 py-2 border-t">${formatNumber(avgViewsPerVideo)}</td>
          <td class="px-4 py-2 border-t">${formatNumber(avgLikesPerVideo)}</td>
          <td class="px-4 py-2 border-t">${avgLikesPerView}%</td>
        </tr>
      `;
    }

    /**
     * CHART RENDERING FUNCTIONS
     * Creates and updates all chart visualizations based on the selected data and metrics
     * @param {Array} data - Array of data objects to visualize
     */
    function renderCharts(data) {
        // Wait for Chart.js to be loaded before rendering
        if (typeof window.Chart === 'undefined') {
            setTimeout(() => renderCharts(data), 120);
            return;
        }

        // Extract data series for charts
        const labels = data.map(d => d.prettyPeriod);
        const videos = data.map(d => d.videos);
        const views = data.map(d => d.views);
        const likes = data.map(d => d.likes);
        const colors = data.map(d => getPeriodColor(d.period));

        // Get canvas context for the combined line chart
        const combinedCtx = document.getElementById("combinedChart").getContext("2d");
        if (combinedChart) combinedChart.destroy(); // Clean up existing chart

        // Create datasets based on selected metrics
        const datasets = [];

        // Add videos dataset if selected
        if (selectedMetrics.includes("videos")) {
            const color = METRICS_COLORS.videos;
            datasets.push({
                label: "Videos",
                data: videos,
                borderColor: color,
                backgroundColor: `${color}33`, // 20% opacity
                borderWidth: 3,
                tension: 0.1,
                yAxisID: 'y-videos'
            });
        }

        // Add views dataset if selected (scaled to thousands)
        if (selectedMetrics.includes("views")) {
            const color = METRICS_COLORS.views;
            datasets.push({
                label: "Views (thousands)",
                data: views.map(v => v / 1000),
                borderColor: color,
                backgroundColor: `${color}33`, // 20% opacity
                borderWidth: 3,
                tension: 0.1,
                yAxisID: 'y-views'
            });
        }

        // Add likes dataset if selected (scaled to thousands)
        if (selectedMetrics.includes("likes")) {
            const color = METRICS_COLORS.likes;
            datasets.push({
                label: "Likes (thousands)",
                data: likes.map(l => l / 1000),
                borderColor: color,
                backgroundColor: `${color}33`, // 20% opacity
                borderWidth: 3,
                tension: 0.1,
                yAxisID: 'y-likes'
            });
        }

        // Create the combined line chart with multiple Y-axes
        combinedChart = new Chart(combinedCtx, {
            type: "line",
            data: {
                labels: labels,
                datasets: datasets
            },
            plugins: [legendTooltipPlugin],
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false,
                },
                stacked: false,
                scales: {
                    // Y-axis for videos (left side)
                    'y-videos': {
                        type: 'linear',
                        display: selectedMetrics.includes("videos"),
                        position: 'left',
                        title: {
                            display: true,
                            text: "Number of Videos",
                            font: {
                                size: 14
                            }
                        },
                        ticks: {
                            font: {
                                size: 12
                            }
                        },
                        grid: {
                            drawOnChartArea: false,
                        }
                    },
                    // Y-axis for views (right side)
                    'y-views': {
                        type: 'linear',
                        display: selectedMetrics.includes("views"),
                        position: 'right',
                        title: {
                            display: true,
                            text: "Views (thousands)",
                            font: {
                                size: 14
                            }
                        },
                        ticks: {
                            font: {
                                size: 12
                            }
                        },
                        grid: {
                            drawOnChartArea: false,
                        }
                    },
                    // Y-axis for likes (right side)
                    'y-likes': {
                        type: 'linear',
                        display: selectedMetrics.includes("likes"),
                        position: 'right',
                        title: {
                            display: true,
                            text: "Likes (thousands)",
                            font: {
                                size: 14
                            }
                        },
                        ticks: {
                            font: {
                                size: 12
                            }
                        },
                        grid: {
                            drawOnChartArea: false,
                        }
                    }
                },
                plugins: {
                    // Chart title
                    title: {
                        display: true,
                        text: 'Tradwife Trend Development',
                        font: {
                            size: 18
                        }
                    },
                    // Legend configuration
                    legend: {
                        labels: {
                            font: {
                                size: 14
                            }
                        },
                        onHover: function (e, legendItem, legend) {
                            // Change cursor to pointer on hover
                            if (e.native && e.native.target) {
                                e.native.target.style.cursor = 'pointer';
                            }
                        },
                        onLeave: function (e, legendItem, legend) {
                            // Reset cursor when leaving
                            if (e.native && e.native.target) {
                                e.native.target.style.cursor = 'default';
                            }
                        }
                    },
                    // Tooltip configuration
                    tooltip: {
                        callbacks: {
                            label: function (context) {
                                const label = context.dataset.label || '';
                                const value = context.parsed.y;
                                // Format tooltip based on metric type
                                if (label.includes('Videos')) {
                                    return `${label}: ${value}`;
                                } else {
                                    return `${label}: ${value}K`;
                                }
                            }
                        }
                    }
                }
            }
        });

        // PIE CHARTS - Show/hide based on selected metrics

        // Videos Pie Chart - Distribution of videos by time period
        if (selectedMetrics.includes("videos")) {
            const videosPieCtx = document.getElementById("videosPieChart").getContext("2d");
            if (videosPieChart) videosPieChart.destroy();
            videosPieChart = new Chart(videosPieCtx, {
                type: "pie",
                data: {
                    labels: labels,
                    datasets: [{
                        label: "Videos",
                        data: videos,
                        backgroundColor: colors,
                        borderColor: colors,
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {
                            position: 'right',
                        },
                        title: {
                            display: true,
                            text: 'Distribution of Videos'
                        }
                    }
                }
            });
            document.getElementById("videosPieContainer").classList.remove("hidden");
        } else {
            document.getElementById("videosPieContainer").classList.add("hidden");
        }

        // Views Pie Chart - Distribution of views by time period
        if (selectedMetrics.includes("views")) {
            const viewsPieCtx = document.getElementById("viewsPieChart").getContext("2d");
            if (viewsPieChart) viewsPieChart.destroy();
            viewsPieChart = new Chart(viewsPieCtx, {
                type: "pie",
                data: {
                    labels: labels,
                    datasets: [{
                        label: "Views",
                        data: views,
                        backgroundColor: colors,
                        borderColor: colors,
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {
                            position: 'right',
                        },
                        title: {
                            display: true,
                            text: 'Distribution of Views'
                        }
                    }
                }
            });
            document.getElementById("viewsPieContainer").classList.remove("hidden");
        } else {
            document.getElementById("viewsPieContainer").classList.add("hidden");
        }

        // Likes Pie Chart - Distribution of likes by time period
        if (selectedMetrics.includes("likes")) {
            const likesPieCtx = document.getElementById("likesPieChart").getContext("2d");
            if (likesPieChart) likesPieChart.destroy();
            likesPieChart = new Chart(likesPieCtx, {
                type: "pie",
                data: {
                    labels: labels,
                    datasets: [{
                        label: "Likes",
                        data: likes,
                        backgroundColor: colors,
                        borderColor: colors,
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {
                            position: 'right',
                        },
                        title: {
                            display: true,
                            text: 'Distribution of Likes'
                        }
                    }
                }
            });
            document.getElementById("likesPieContainer").classList.remove("hidden");
        } else {
            document.getElementById("likesPieContainer").classList.add("hidden");
        }
    }

    /**
     * BUBBLE CHART FUNCTIONS
     * Creates a bubble chart showing relationships between time, likes, videos, and views
     */

    /**
     * Converts a period string to a Date object for timeline visualization
     * @param {string} period - Period identifier (e.g., '2024', '2024_first_third')
     * @returns {Date} Date object representing the middle of the period
     */
    function parsePeriodToDate(period) {
        // period can be 'YYYY' or 'YYYY_first_third' | 'YYYY_second_third' | 'YYYY_third_third'
        try {
            if (!period.includes('_')) {
                const y = parseInt(period, 10);
                return new Date(y, 6, 1); // mid-year (July 1)
            }
            const [yStr, part] = period.split('_');
            const y = parseInt(yStr, 10);
            if (part === 'first_third') return new Date(y, 1, 15);   // mid-Feb
            if (part === 'second_third') return new Date(y, 5, 15);  // mid-Jun
            if (part === 'third_third') return new Date(y, 9, 15);   // mid-Oct
            return new Date(parseInt(yStr,10), 6, 1);
        } catch (e) {
            return new Date();
        }
    }

    /**
     * Interpolates between two colors based on a parameter t
     * @param {Array} minColor - RGB color array [r,g,b] for minimum value
     * @param {Array} maxColor - RGB color array [r,g,b] for maximum value
     * @param {number} t - Interpolation parameter (0-1)
     * @returns {string} CSS RGB color string
     */
    function interpolateColor(minColor, maxColor, t) {
        // colors as [r,g,b] 0-255; t in [0,1]
        const r = Math.round(minColor[0] + (maxColor[0] - minColor[0]) * t);
        const g = Math.round(minColor[1] + (maxColor[1] - minColor[1]) * t);
        const b = Math.round(minColor[2] + (maxColor[2] - minColor[2]) * t);
        return `rgb(${r}, ${g}, ${b})`;
    }

    /**
     * Gets a color for a views value based on its position in the range
     * @param {number} value - Views value to get color for
     * @param {number} min - Minimum views value in dataset
     * @param {number} max - Maximum views value in dataset
     * @returns {string} CSS RGB color string
     */
    function getViewsColor(value, min, max) {
        if (max === min) return 'rgb(30, 136, 229)'; // Default blue if no range
        const t = Math.max(0, Math.min(1, (value - min) / (max - min)));
        // Color gradient from light blue to dark blue
        const light = [187, 222, 251]; // #BBDEFB
        const dark = [13, 71, 161];    // #0D47A1
        return interpolateColor(light, dark, t);
    }

    /**
     * Renders the bubble chart using CanvasJS
     * Bubble chart shows: x = time, y = likes, z (size) = videos, color = views
     * @param {Array} data - Array of data objects to visualize
     */
    function renderBubbleChart(data) {
        // Wait for CanvasJS to be loaded before rendering
        if (typeof window.CanvasJS === 'undefined') {
            setTimeout(() => renderBubbleChart(data), 120);
            return;
        }

        // Find min/max views for color scaling
        const minViews = Math.min(...data.map(d => d.views));
        const maxViews = Math.max(...data.map(d => d.views));

        // Create data points for the bubble chart
        const dataPoints = data.map(d => ({
            x: parsePeriodToDate(d.period),      // Time on x-axis
            y: d.likes,                          // Likes on y-axis
            z: d.videos,                         // Videos as bubble size
            color: getViewsColor(d.views, minViews, maxViews), // Views as color
            label: d.prettyPeriod,               // Period label for tooltip
            views: d.views                       // Views for tooltip
        }));

        // Configure chart options
        const options = {
            animationEnabled: true,
            // Use appropriate theme based on current mode
            theme: document.documentElement.classList.contains('dark') ? 'dark2' : 'light2',
            backgroundColor: 'transparent',
            axisX: {
                title: 'Zeit',
                valueFormatString: 'YYYY MMM',
                lineColor: '#94a3b8',
                labelFontColor: '#334155'
            },
            axisY: {
                title: 'Likes',
                lineColor: '#94a3b8',
                labelFontColor: '#334155'
            },
            // Configure tooltip to show all metrics
            toolTip: {
                shared: false,
                content: '{label}<br/>Likes: {y}<br/>Videos: {z}<br/>Views: {views}'
            },
            data: [{
                type: 'bubble',
                indexLabelFontSize: 12,
                dataPoints
            }]
        };

        // Create and render the chart
        if (!document.getElementById('bubbleChartContainer')) return;
        bubbleChart = new CanvasJS.Chart('bubbleChartContainer', options);
        bubbleChart.render();
    }

    /**
     * Main refresh function that updates all visualizations
     * Called when data is loaded or when filters change
     */
    function refresh() {
        // Get data for the current view
        const data = dataStore[currentView] || [];
        const subtitle = document.getElementById("subtitle");

        // Update subtitle based on current view
        if (currentView === "all") {
            subtitle.textContent = "Every year - Tradwife Content Analysis";
        } else if (currentView === "detailed") {
            subtitle.textContent = "Detailed Tradwife Content Analysis";
        } else {
            subtitle.textContent = `Tradwife Content Analysis - ${currentView}`;
        }

        // Render all visualizations with the current data
        renderTable(data);
        renderCharts(data);
        renderBubbleChart(data);

        // Show/hide pie charts section based on selected metrics
        const pieChartsSection = document.querySelector('.mt-8.grid.gap-8.lg\\:grid-cols-3');
        if (selectedMetrics.length === 0) {
            pieChartsSection.classList.add('hidden');
        } else {
            pieChartsSection.classList.remove('hidden');
        }
    }

    /**
     * EVENT HANDLERS AND INITIALIZATION
     * Sets up interactive controls and initializes the UI
     */

    // Add event listener to year selector dropdown
    document.getElementById('year-selector').addEventListener('change', (e) => {
        currentView = e.target.value;
        refresh();
    });

    /**
     * Sets up the metrics dropdown with checkboxes and event handlers
     * Allows users to select which metrics to display in the visualizations
     */
    const setupMetricsDropdown = () => {
        const dropdownButton = document.getElementById("metricsDropdown");
        const dropdownContent = document.getElementById("metricsDropdownContent");
        const selectAllCheckbox = document.getElementById("selectAllMetrics");
        const metricCheckboxes = document.querySelectorAll(".metric-checkbox");

        // Toggle dropdown visibility when button is clicked
        dropdownButton.addEventListener("click", () => {
            dropdownContent.classList.toggle("hidden");
        });

        // Close dropdown when clicking outside of it
        document.addEventListener("click", (e) => {
            if (!dropdownButton.contains(e.target) && !dropdownContent.contains(e.target)) {
                dropdownContent.classList.add("hidden");
            }
        });

        // "Select All" checkbox functionality
        selectAllCheckbox.addEventListener("change", () => {
            const isChecked = selectAllCheckbox.checked;
            // Update all metric checkboxes to match the "Select All" state
            metricCheckboxes.forEach(checkbox => {
                checkbox.checked = isChecked;
            });
            updateSelectedMetrics();
            updateDropdownButtonText();
        });

        // Add event listeners to individual metric checkboxes
        metricCheckboxes.forEach(checkbox => {
            checkbox.addEventListener("change", () => {
                updateSelectedMetrics();
                updateDropdownButtonText();
            });
        });

        /**
         * Updates the selectedMetrics array based on checked checkboxes
         * Then refreshes the visualizations to reflect the changes
         */
        function updateSelectedMetrics() {
            selectedMetrics = [];
            document.querySelectorAll(".metric-checkbox:checked").forEach(checkbox => {
                selectedMetrics.push(checkbox.value);
            });

            // Update "Select All" checkbox state based on whether all metrics are selected
            const allCheckboxes = document.querySelectorAll(".metric-checkbox");
            const checkedCheckboxes = document.querySelectorAll(".metric-checkbox:checked");
            selectAllCheckbox.checked = allCheckboxes.length === checkedCheckboxes.length;

            // Refresh visualizations with the new metrics selection
            refresh();
        }

        /**
         * Updates the dropdown button text based on selected metrics
         */
        function updateDropdownButtonText() {
            const allCheckboxes = document.querySelectorAll(".metric-checkbox");
            const checkedCheckboxes = document.querySelectorAll(".metric-checkbox:checked");

            // Set appropriate text based on selection state
            if (checkedCheckboxes.length === 0) {
                dropdownButton.querySelector("span").textContent = "Keine Metrics";
            } else if (checkedCheckboxes.length === allCheckboxes.length) {
                dropdownButton.querySelector("span").textContent = "Alle Metrics";
            } else if (checkedCheckboxes.length === 1) {
                // Capitalize first letter of single selected metric
                dropdownButton.querySelector("span").textContent = checkedCheckboxes[0].value.charAt(0).toUpperCase() + checkedCheckboxes[0].value.slice(1);
            } else {
                // Show count of selected metrics
                dropdownButton.querySelector("span").textContent = `${checkedCheckboxes.length} Metrics`;
            }
        }
    };

    // Initialize the metrics dropdown when the page loads
    setupMetricsDropdown();
</script>

<!-- 
    Dark Mode JavaScript
    Handles theme switching between light and dark modes
-->
<script>
    /**
     * Dark Mode Functionality
     * Initializes theme based on user preference and provides toggle functionality
     */
    document.addEventListener('DOMContentLoaded', function () {
        const darkModeToggle = document.getElementById('darkModeToggle');
        const htmlElement = document.documentElement;
        const moonIcon = '<i class="fas fa-moon"></i>';  // Icon for light mode (switch to dark)
        const sunIcon = '<i class="fas fa-sun"></i>';    // Icon for dark mode (switch to light)

        // Check for saved theme preference or use system preference
        const savedTheme = localStorage.getItem('theme');
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

        // Apply the saved theme or system preference on initial load
        if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
            htmlElement.classList.add('dark');
            darkModeToggle.innerHTML = sunIcon;
        } else {
            htmlElement.classList.remove('dark');
            darkModeToggle.innerHTML = moonIcon;
        }

        // Toggle dark mode when the button is clicked
        darkModeToggle.addEventListener('click', function () {
            if (htmlElement.classList.contains('dark')) {
                // Switch to light mode
                htmlElement.classList.remove('dark');
                localStorage.setItem('theme', 'light');
                darkModeToggle.innerHTML = moonIcon;
            } else {
                // Switch to dark mode
                htmlElement.classList.add('dark');
                localStorage.setItem('theme', 'dark');
                darkModeToggle.innerHTML = sunIcon;
            }
        });
    });
</script>

<!-- 
    Conclusion Section
    Summarizes key findings and implications of the tradwife trend analysis
-->
<section class="max-w-7xl mx-auto mt-6 bg-white rounded-2xl shadow p-6 space-y-3">
    <h2 class="text-xl font-semibold">Conclusion</h2>
    <p class="text-gray-700">In conclusion, the trend began growing in 2023 and has not stopped expanding. However, the number of likes per view dropped for a period. One possible explanation is that as the trend reaches audiences beyond its core community, more people may watch without endorsing the content by liking it. Another possibility is that some viewers are reluctant to support the trend.</p>
</section>

{% include 'partials/footer.html' %}
</body>
</html>

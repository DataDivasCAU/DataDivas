<!DOCTYPE html>
<html lang="en" class="light">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Posts per Party</title>
    <script src="https://cdn.tailwindcss.com" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js" defer></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"/>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
</head>
<body class="min-h-screen bg-gradient-to-br from-indigo-50 to-blue-100 text-gray-900">
{% include 'partials/dark_mode_toggle.html' %}

{% set page_title = 'Posts per Party' %}
{% include 'partials/page_header.html' %}

<!-- Introduction -->
<section class="max-w-5xl mx-auto mt-4 bg-white rounded-2xl shadow p-6 space-y-3">
    <h2 class="text-xl font-semibold">Introduction</h2>
    <p class="text-gray-700">This page compares parties‚Äô social media posting activity (number of posts) with their election results. We look at two election periods (2021 and 2025) and examine both the distribution within a year and the changes between years.</p>
    <p class="text-gray-700">Using the controls above, you can choose the election period and include or exclude specific parties. The charts and the table update based on your selection.</p>
</section>
<div class="max-w-5xl mx-auto mt-6">
    <div class="flex items-center gap-3 flex-wrap justify-center mb-6">
        <label for="dataset" class="font-medium">Election period:</label>
        <select id="dataset" class="border rounded p-2 bg-white">
            <option value="first">Election 2025</option>
            <option value="second">Election 2021</option>
            <option value="both">Both elections</option>
        </select>

        <label for="partyDropdown" class="font-medium">Parties:</label>
        <div class="relative inline-block">
            <button id="partyDropdown" type="button"
                    class="border rounded p-2 bg-white flex items-center justify-between min-w-[150px] party-dropdown-button">
                <span>No party</span>
                <svg class="w-4 h-4 ml-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                     xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                </svg>
            </button>
            <div id="partyDropdownContent"
                 class="absolute z-10 hidden bg-white border mt-1 party-dropdown-content max-h-60 overflow-y-auto min-w-[200px]">
                <div class="p-2 border-b">
                    <label class="flex items-center cursor-pointer">
                        <input type="checkbox" id="selectAllParties" class="mr-2 custom-checkbox">
                        <span>Select all</span>
                    </label>
                </div>
                <div id="partyCheckboxes" class="p-2">
                    <!-- Will be populated dynamically -->
                </div>
            </div>
        </div>

    </div>

    <div id="subtitle" class="text-sm text-gray-500 mt-1 text-center mb-5">View: 2025</div>

    <!-- Tabelle -->
    <div class="overflow-x-auto shadow rounded-2xl mb-8 bg-white">
        <table id="partyTable" class="min-w-full border-collapse">
            <thead>
            <tr class="bg-gray-100 text-left" id="tableHead"></tr>
            </thead>
            <tbody></tbody>
            <tfoot id="tableFoot"></tfoot>
        </table>
    </div>

    <!-- Charts -->
    <section class="grid gap-8 lg:grid-cols-2">
        <!-- Posts Chart Card -->
        <div class="max-w-xl bg-white rounded-2xl shadow p-4">
            <div id="chartTitle" class="mb-2 font-semibold">Posts 2025 (Pie)</div>
            <canvas id="pieChart"></canvas>
        </div>

        <!-- Election Chart Card -->
        <div class="max-w-xl bg-white rounded-2xl shadow p-4">
            <div id="electionChartTitle" class="mb-2 font-semibold">Election results 2025 (Pie)</div>
            <canvas id="electionPieChart"></canvas>
        </div>

        <!-- Combined Chart Card (made large) -->
        <div id="combinedCard" class="bg-white rounded-2xl shadow p-4 w-full lg:col-span-2">
            <div id="combinedChartTitle" class="mb-2 font-semibold">Posts and election results 2025</div>
            <canvas id="combinedChart"></canvas>
        </div>

        <!-- Scatter nur bei "both" (made large) -->
        <div id="scatterCard" class="bg-white rounded-2xl shadow p-4 w-full lg:col-span-2 hidden">
            <div class="flex items-center justify-between mb-2">
                <div id="scatterTitle" class="font-semibold hidden">
                    ŒîPosts 2025‚Äì2021 vs. ŒîElection (pp)
                </div>
                <button id="saveScatterBtn" class="text-sm px-3 py-1 rounded bg-indigo-600 text-white hover:bg-indigo-700 hidden" title="Save scatter as image">
                    Save image
                </button>
            </div>
            <canvas id="scatterChart"></canvas>
        </div>
    </section>

    <!-- Individual Party Charts -->
    <section id="partyChartsSection" class="mt-8">
            <h2 class="text-xl font-bold mb-4">Individual parties</h2>
            <div id="partyCharts" class="grid gap-8 lg:grid-cols-2">
                <!-- Will be populated dynamically -->
            </div>
        </section>

    <!-- Cards -->
    <section class="grid sm:grid-cols-2 lg:grid-cols-3 gap-6 mt-12">
        <div class="block rounded-2xl bg-white shadow hover:shadow-lg transition p-6">
            <h2 class="text-xl font-bold text-indigo-700 mb-2">üìÇ Data (Posts)</h2>
            <p class="text-gray-600">Raw data for posts per party.</p>
            <div class="flex mt-4 space-x-3">
                <button onclick="viewJsonData('/data.json')"
                        class="px-3 py-2 rounded bg-blue-100 hover:bg-blue-200 text-blue-800 flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" fill="none" viewBox="0 0 24 24"
                         stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                              d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                              d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"/>
                    </svg>
                    View
                </button>
                <div class="relative">
                    <button onclick="toggleDownloadOptions('data')"
                            class="px-3 py-2 rounded bg-green-100 hover:bg-green-200 text-green-800 flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" fill="none" viewBox="0 0 24 24"
                             stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                  d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/>
                        </svg>
                        Download
                    </button>
                    <div id="data-download-options"
                         class="hidden absolute right-0 mt-2 w-48 bg-white rounded-md shadow-lg z-10">
                        <a href="/data.json" download class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">Download JSON</a>
                        <a href="/download/posts-csv" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">Download CSV</a>
                    </div>
                </div>
            </div>
        </div>

        <div class="block rounded-2xl bg-white shadow hover:shadow-lg transition p-6">
            <h2 class="text-xl font-bold text-indigo-700 mb-2">üó≥Ô∏è Election data</h2>
            <p class="text-gray-600">Parties‚Äô election results.</p>
            <div class="flex mt-4 space-x-3">
                <button onclick="viewJsonData('/election.json')"
                        class="px-3 py-2 rounded bg-blue-100 hover:bg-blue-200 text-blue-800 flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" fill="none" viewBox="0 0 24 24"
                         stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                              d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                              d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"/>
                    </svg>
                    View
                </button>
                <div class="relative">
                    <button onclick="toggleDownloadOptions('election')"
                            class="px-3 py-2 rounded bg-green-100 hover:bg-green-200 text-green-800 flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" fill="none" viewBox="0 0 24 24"
                             stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                  d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/>
                        </svg>
                        Download
                    </button>
                    <div id="election-download-options"
                         class="hidden absolute right-0 mt-2 w-48 bg-white rounded-md shadow-lg z-10">
                        <a href="/election.json" download
                           class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">Download JSON</a>
                        <a href="/download/election-csv"
                           class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">Download CSV</a>
                    </div>
                </div>
            </div>
        </div>

        <a href="{{ url_for('post_per_party_stats') }}"
           class="block rounded-2xl bg-white shadow hover:shadow-lg transition transform hover:-translate-y-1 p-6">
            <h2 class="text-xl font-bold text-indigo-700 mb-2">üìà Stats</h2>
            <p class="text-gray-600">Shows a table and chart with current YouTube statistics for the parties.</p>
        </a>
    </section>

    <!-- JSON Viewer Modal -->
    <div id="jsonViewerModal" class="fixed inset-0 bg-black bg-opacity-50 hidden flex items-center justify-center z-50">
        <div class="bg-white rounded-lg shadow-xl max-w-4xl w-full max-h-[80vh] flex flex-col">
            <div class="flex justify-between items-center border-b p-4">
                <h3 class="text-xl font-semibold" id="jsonViewerTitle">JSON Data</h3>
                <button onclick="closeJsonViewer()" class="text-gray-500 hover:text-gray-700">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24"
                         stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                    </svg>
                </button>
            </div>
            <div class="overflow-auto p-4 flex-grow">
                <pre id="jsonViewerContent" class="text-sm bg-gray-50 p-4 rounded"></pre>
            </div>
        </div>
    </div>
</div>

<script defer>

    // JSON Viewer functions
    function viewJsonData(url) {
        fetch(url)
            .then(response => response.json())
            .then(data => {
                // Set the title based on the URL
                const title = url.includes('data.json') ? 'Posts per party data' : 'Election results data';
                document.getElementById('jsonViewerTitle').textContent = title;

                // Format JSON with 2 spaces indentation and display it
                document.getElementById('jsonViewerContent').textContent = JSON.stringify(data, null, 2);

                // Show the modal
                document.getElementById('jsonViewerModal').classList.remove('hidden');
            })
            .catch(error => {
                console.error('Error fetching JSON data:', error);
                alert('Error loading data. Please try again later.');
            });
    }

    function closeJsonViewer() {
        document.getElementById('jsonViewerModal').classList.add('hidden');
    }

    // Close modal when clicking outside the content
    document.getElementById('jsonViewerModal').addEventListener('click', function (event) {
        if (event.target === this) {
            closeJsonViewer();
        }
    });

    // Download options toggle
    function toggleDownloadOptions(type) {
        const optionsId = `${type}-download-options`;
        const options = document.getElementById(optionsId);

        // Close all other dropdowns first
        document.querySelectorAll('[id$="-download-options"]').forEach(el => {
            if (el.id !== optionsId) {
                el.classList.add('hidden');
            }
        });

        // Toggle this dropdown
        options.classList.toggle('hidden');
    }

    // Close dropdowns when clicking outside
    document.addEventListener('click', function (event) {
        if (!event.target.closest('button[onclick^="toggleDownloadOptions"]')) {
            document.querySelectorAll('[id$="-download-options"]').forEach(el => {
                el.classList.add('hidden');
            });
        }
    });

    // Convert JSON to CSV and download
    function downloadCSV(url, filename) {
        fetch(url)
            .then(response => response.json())
            .then(data => {
                let csv = '';

                // Handle different data structures
                if (url.includes('data.json')) {
                    // For posts data
                    // Get the relevant keys (electionPosts2021, electionPosts2025, diffPosts2025)
                    const dataKeys = Object.keys(data).filter(key => key.includes('Posts'));
                    const yearKeys = dataKeys.filter(key => key.includes('election')); // Only electionPosts keys
                    const parties = new Set();

                    // Collect all party names
                    yearKeys.forEach(key => {
                        Object.keys(data[key]).forEach(party => parties.add(party));
                    });

                    // Create CSV header row
                    csv += 'Party,' + yearKeys.map(key => key.replace('electionPosts', 'Posts ')) + ',Diff\n';

                    // Create rows for each party
                    Array.from(parties).forEach(party => {
                        let row = party;
                        yearKeys.forEach(key => {
                            row += ',' + (data[key][party] !== undefined ? data[key][party] : '');
                        });

                        // Add diff column
                        row += ',' + (data['diffPosts2025'] && data['diffPosts2025'][party] !== undefined ? data['diffPosts2025'][party] : '');

                        csv += row + '\n';
                    });
                } else if (url.includes('election.json')) {
                    // For election data
                    // Handle nested structure with arrays
                    const years = Object.keys(data).filter(key => key !== 'diffElection');
                    const parties = new Set();

                    // Collect all party names
                    years.forEach(year => {
                        if (Array.isArray(data[year]) && data[year].length > 0) {
                            Object.keys(data[year][0]).forEach(party => parties.add(party));
                        }
                    });

                    // Add diff parties too
                    if (data.diffElection) {
                        Object.keys(data.diffElection).forEach(party => parties.add(party));
                    }

                    // Create CSV header row
                    csv += 'Party,' + years.map(y => y.replace('election', 'Election ')) + ',Diff\n';

                    // Create rows for each party
                    Array.from(parties).forEach(party => {
                        let row = party;
                        years.forEach(year => {
                            if (Array.isArray(data[year]) && data[year].length > 0) {
                                row += ',' + (data[year][0][party] !== undefined ? data[year][0][party] : '');
                            } else {
                                row += ',';
                            }
                        });

                        // Add diff column
                        row += ',' + (data.diffElection && data.diffElection[party] !== undefined ? data.diffElection[party] : '');

                        csv += row + '\n';
                    });
                }

                // Create download link
                const blob = new Blob([csv], {type: 'text/csv;charset=utf-8;'});
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);

                link.setAttribute('href', url);
                link.setAttribute('download', filename + '.csv');
                link.style.visibility = 'hidden';

                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                // Hide dropdown after download
                document.querySelectorAll('[id$="-download-options"]').forEach(el => {
                    el.classList.add('hidden');
                });
            })
            .catch(error => {
                console.error('Error converting to CSV:', error);
                alert('Error converting data. Please try again later.');
            });
    }

    let dataStore = {
        posts2025: [],
        posts2021: [],
        election2025: new Map(),
        election2021: new Map(),
        diffElection: new Map(),
    };

    let currentPeriod = "first";
    let pieChart, electionPieChart, combinedChart, scatterChart;
    let partyCharts = new Map(); // Store individual party charts
    let selectedParties = []; // Store selected parties
    let sortState = {key: null, dir: 1};

    // === Parteifarben ===
    const PARTY_COLORS = new Map([
        ["cdu", "#000000"], ["csu", "#000000"],
        ["spd", "#E3000F"], ["fdp", "#FFED00"],
        ["gruene", "#1AA037"], ["gr√ºne", "#1AA037"],
        ["die linke", "#BE3075"], ["linke", "#BE3075"],
        ["afd", "#009EE0"], ["bsw", "#00B3A4"],
        ["sonstige", "#9CA3AF"],
    ]);
    const norm = (p) => String(p).toLowerCase();
    const pretty = (p) => {
        const m = {
            gruene: "Gr√ºne", gr√ºne: "Gr√ºne", linke: "Linke",
            cdu: "CDU", csu: "CSU", spd: "SPD", fdp: "FDP",
            afd: "AfD", bsw: "BSW"
        };
        const k = norm(p);
        return m[k] || p;
    };
    const fmtPct = (v) =>
        `${(Number(v) || 0).toLocaleString("de-DE", {maximumFractionDigits: 2})}%`;
    const getPartyColor = (label) => {
        const k = norm(label);
        if (PARTY_COLORS.has(k)) return PARTY_COLORS.get(k);
        if (k.includes("gruen") || k.includes("gr√ºn")) return "#1AA037";
        if (k.includes("linke")) return "#BE3075";
        if (k.includes("cdu") || k.includes("csu")) return "#000000";
        if (k.includes("spd")) return "#E3000F";
        if (k.includes("fdp")) return "#FFED00";
        if (k.includes("afd")) return "#009EE0";
        if (k.includes("bsw")) return "#00B3A4";
        return "#9CA3AF";
    };

    // ---- Daten laden ----
    Promise.all([fetch("/data.json"), fetch("/election.json")])
        .then(async ([pRes, eRes]) => {
            if (!pRes.ok) throw new Error(`data.json HTTP ${pRes.status}`);
            if (!eRes.ok) throw new Error(`election.json HTTP ${eRes.status}`);
            return [await pRes.json(), await eRes.json()];
        })
        .then(([postsData, electData]) => {
            // POSTS: neues Schema
            const p2025 = postsData.electionPosts2025 || {};
            const p2021 = postsData.electionPosts2021 || {};
            const rows2025 = Object.entries(p2025).map(([party, posts]) => ({
                party: pretty(party),
                posts: Number(posts) || 0
            }));
            const rows2021 = Object.entries(p2021).map(([party, posts]) => ({
                party: pretty(party),
                posts: Number(posts) || 0
            }));

            // ELECTION
            const e25 = (electData.election2025 && electData.election2025[0]) || {};
            const e21 = (electData.election2021 && electData.election2021[0]) || {};
            const dE = electData.diffElection || {};
            dataStore.election2025 = new Map(Object.entries(e25).map(([k, v]) => [pretty(k), Number(v) || 0]));
            dataStore.election2021 = new Map(Object.entries(e21).map(([k, v]) => [pretty(k), Number(v) || 0]));
            dataStore.diffElection = new Map(Object.entries(dE).map(([k, v]) => [pretty(k), Number(v) || 0]));

            // electionCount mergen
            dataStore.posts2025 = mergeElection(rows2025, dataStore.election2025);
            dataStore.posts2021 = mergeElection(rows2021, dataStore.election2021);

            // Populate party dropdown
            populatePartyDropdown();

            refresh();
        })
        .catch(err => console.error("Ladefehler:", err));

    function mergeElection(rows, map) {
        const parties = new Set([...rows.map(r => r.party), ...map.keys()]);
        return [...parties].map(p => {
            const r = rows.find(x => x.party === p) || {party: p, posts: 0};
            return {party: p, posts: r.posts, electionCount: map.get(p) || 0};
        });
    }

    // Tabellenkopf mit Sortierung
    function renderHeader(columns) {
        const thead = document.getElementById("tableHead");
        thead.innerHTML = "";
        columns.forEach(col => {
            const th = document.createElement("th");
            th.className = "px-4 py-2 border-b cursor-pointer select-none";
            th.dataset.sort = col.key;
            th.textContent = col.label + " " +
                (sortState.key === col.key ? (sortState.dir === 1 ? "‚ñ≤" : "‚ñº") : "‚ñ≤‚ñº");
            th.addEventListener("click", () => {
                if (sortState.key === col.key) sortState.dir *= -1;
                else {
                    sortState.key = col.key;
                    sortState.dir = 1;
                }
                refresh();
            });
            thead.appendChild(th);
        });
    }

    function renderTableSingle(rows, year) {
        renderHeader([
            {key: "party", label: "Party"},
            {key: "posts", label: `Posts ${year}`},
            {key: "electionCount", label: `Election ${year} (%)`},
        ]);

        const tbody = document.querySelector("#partyTable tbody");
        const tfoot = document.getElementById("tableFoot");
        tbody.innerHTML = "";
        tfoot.innerHTML = "";

        // Filter rows based on selected parties
        let data = selectedParties.length > 0
            ? rows.filter(r => selectedParties.includes(r.party))
            : rows.slice();

        if (sortState.key) {
            data.sort((a, b) => {
                const va = a[sortState.key], vb = b[sortState.key];
                return (va < vb ? -1 : va > vb ? 1 : 0) * sortState.dir;
            });
        }

        let sumPosts = 0;
        data.forEach(row => {
            sumPosts += row.posts;
            const tr = document.createElement("tr");
            tr.className = "hover:bg-gray-50 transition-colors";
            tr.innerHTML = `
          <td class="px-4 py-2 border-b font-medium">
            <span class="inline-block w-3 h-3 rounded-sm align-middle mr-2"
                  style="background:${getPartyColor(row.party)}"></span>
            ${row.party}
          </td>
          <td class="px-4 py-2 border-b">${row.posts}</td>
          <td class="px-4 py-2 border-b">${fmtPct(row.electionCount)}</td>
        `;
            tbody.appendChild(tr);
        });

        tfoot.innerHTML = `
        <tr class="bg-gray-50 font-semibold">
          <td class="px-4 py-2 border-t">Summe</td>
          <td class="px-4 py-2 border-t">${sumPosts}</td>
          <td class="px-4 py-2 border-t">‚Äî</td>
        </tr>
      `;
    }

    function renderTableBoth() {
        const p25 = new Map((dataStore.posts2025 || []).map(r => [r.party, r.posts]));
        const p21 = new Map((dataStore.posts2021 || []).map(r => [r.party, r.posts]));
        const e25 = dataStore.election2025 || new Map();
        const e21 = dataStore.election2021 || new Map();
        const dE = dataStore.diffElection || new Map();

        // Get all unique parties from all datasets
        let parties = [...new Set([...p25.keys(), ...p21.keys(), ...e25.keys(), ...e21.keys(), ...dE.keys()])];

        // Filter parties based on selection
        if (selectedParties.length > 0) {
            parties = parties.filter(party => selectedParties.includes(party));
        }

        renderHeader([
            {key: "party", label: "Party"},
            {key: "posts2025", label: "Posts 2025"},
            {key: "election2025", label: "Election 2025 (%)"},
            {key: "posts2021", label: "Posts 2021"},
            {key: "election2021", label: "Election 2021 (%)"},
            {key: "diffPosts", label: "Diff Posts (25‚Äì21)"},
            {key: "diffElection", label: "Diff Election (pp)"},
        ]);

        const tbody = document.querySelector("#partyTable tbody");
        const tfoot = document.getElementById("tableFoot");
        tbody.innerHTML = "";
        tfoot.innerHTML = "";

        let data = parties.map(p => {
            const v25 = p25.get(p) || 0;
            const v21 = p21.get(p) || 0;
            const e_25 = e25.get(p) || 0;
            const e_21 = e21.get(p) || 0;
            const de = dE.has(p) ? dE.get(p) : (e_25 - e_21);
            return {
                party: p,
                posts2025: v25,
                election2025: e_25,
                posts2021: v21,
                election2021: e_21,
                diffPosts: v25 - v21,
                diffElection: de
            };
        });

        if (sortState.key) {
            data.sort((a, b) => {
                const va = a[sortState.key], vb = b[sortState.key];
                return (va < vb ? -1 : va > vb ? 1 : 0) * sortState.dir;
            });
        }

        let sum25 = 0, sum21 = 0;
        data.forEach(row => {
            sum25 += row.posts2025;
            sum21 += row.posts2021;

            const tr = document.createElement("tr");
            tr.className = "hover:bg-gray-50 transition-colors";
            tr.innerHTML = `
          <td class="px-4 py-2 border-b font-medium">
            <span class="inline-block w-3 h-3 rounded-sm align-middle mr-2"
                  style="background:${getPartyColor(row.party)}"></span>
            ${row.party}
          </td>
          <td class="px-4 py-2 border-b">${row.posts2025}</td>
          <td class="px-4 py-2 border-b">${fmtPct(row.election2025)}</td>
          <td class="px-4 py-2 border-b">${row.posts2021}</td>
          <td class="px-4 py-2 border-b">${fmtPct(row.election2021)}</td>
          <td class="px-4 py-2 border-b ${row.diffPosts >= 0 ? 'text-green-700' : 'text-red-700'}">
            ${row.diffPosts >= 0 ? '+' + row.diffPosts : row.diffPosts}
          </td>
          <td class="px-4 py-2 border-b ${row.diffElection >= 0 ? 'text-green-700' : 'text-red-700'}">
            ${(row.diffElection >= 0 ? '+' : '')}${row.diffElection.toLocaleString("de-DE", {maximumFractionDigits: 2})} pp
          </td>
        `;
            tbody.appendChild(tr);
        });

        const totalDiff = sum25 - sum21;
        tfoot.innerHTML = `
        <tr class="bg-gray-50 font-semibold">
          <td class="px-4 py-2 border-t">Summe</td>
          <td class="px-4 py-2 border-t">${sum25}</td>
          <td class="px-4 py-2 border-t">‚Äî</td>
          <td class="px-4 py-2 border-t">${sum21}</td>
          <td class="px-4 py-2 border-t">‚Äî</td>
          <td class="px-4 py-2 border-t ${totalDiff >= 0 ? 'text-green-700' : 'text-red-700'}">
            ${totalDiff >= 0 ? '+' : ''}${totalDiff}
          </td>
          <td class="px-4 py-2 border-t">‚Äî</td>
        </tr>
      `;

        // Scatter rendern
        renderScatter(data);
    }

    function renderPie(rows, year) {
        const ctx = document.getElementById("pieChart").getContext("2d");
        if (pieChart) pieChart.destroy();
        if (!rows || rows.length === 0) return;

        // Filter rows based on selected parties
        const filteredRows = selectedParties.length > 0
            ? rows.filter(r => selectedParties.includes(r.party))
            : rows;

        if (filteredRows.length === 0) return;

        const labels = filteredRows.map(r => r.party);
        const values = filteredRows.map(r => r.posts);
        const total = values.reduce((a, b) => a + b, 0);
        const backgroundColor = labels.map(getPartyColor);

        pieChart = new Chart(ctx, {
            type: "pie",
            data: {labels, datasets: [{data: values, backgroundColor}]},
            options: {
                plugins: {
                    legend: {position: "right"},
                    tooltip: {
                        callbacks: {
                            label: (context) => {
                                const value = context.raw;
                                const percent = total ? ((value / total) * 100).toFixed(1) : "0.0";
                                return `${context.label}: ${value} (${percent}%)`;
                            }
                        }
                    }
                }
            }
        });

        document.getElementById("chartTitle").textContent = `1. Chart: Posts only (${year})`;
    }

    function renderElectionPie(year) {
        const ctx = document.getElementById("electionPieChart").getContext("2d");
        if (electionPieChart) electionPieChart.destroy();

        const electionMap = year === 2025 ? dataStore.election2025 : dataStore.election2021;
        if (!electionMap || electionMap.size === 0) return;

        // Filter parties based on selection
        const filteredParties = selectedParties.length > 0
            ? [...electionMap.keys()].filter(party => selectedParties.includes(party))
            : [...electionMap.keys()];

        if (filteredParties.length === 0) return;

        const labels = filteredParties;
        const values = filteredParties.map(party => electionMap.get(party));
        const backgroundColor = labels.map(getPartyColor);

        electionPieChart = new Chart(ctx, {
            type: "pie",
            data: {labels, datasets: [{data: values, backgroundColor}]},
            options: {
                plugins: {
                    legend: {position: "right"},
                    tooltip: {
                        callbacks: {
                            label: (context) => {
                                const value = context.raw;
                                return `${context.label}: ${fmtPct(value)}`;
                            }
                        }
                    }
                }
            }
        });

        document.getElementById("electionChartTitle").textContent = `2. Chart: Election results only (${year})`;
    }

    function renderCombinedChart(year) {
        const ctx = document.getElementById("combinedChart").getContext("2d");
        if (combinedChart) combinedChart.destroy();

        const rows = year === 2025 ? dataStore.posts2025 : dataStore.posts2021;
        const electionMap = year === 2025 ? dataStore.election2025 : dataStore.election2021;

        if (!rows || rows.length === 0 || !electionMap || electionMap.size === 0) return;

        // Get parties that exist in both datasets
        let parties = rows.filter(r => electionMap.has(r.party)).map(r => r.party);

        // Filter parties based on selection
        if (selectedParties.length > 0) {
            parties = parties.filter(party => selectedParties.includes(party));
        }

        // Skip if no matching parties
        if (parties.length === 0) return;

        const labels = parties;
        const postValues = parties.map(p => {
            const row = rows.find(r => r.party === p);
            return row ? row.posts : 0;
        });

        const electionValues = parties.map(p => electionMap.get(p) || 0);
        const backgroundColor = labels.map(getPartyColor);

        // Scale the values to make them comparable in the chart
        const maxPosts = Math.max(...postValues);
        const scaledPosts = postValues.map(v => (v / maxPosts) * 100);

        combinedChart = new Chart(ctx, {
            type: "bar",
            data: {
                labels: labels,
                datasets: [
                    {
                        label: "Posts (scaled)",
                        data: scaledPosts,
                        backgroundColor: backgroundColor.map(c => c + "80"), // Add transparency
                        borderColor: backgroundColor,
                        borderWidth: 1
                    },
                    {
                        label: "Election results (%)",
                        data: electionValues,
                        backgroundColor: backgroundColor,
                        borderColor: backgroundColor.map(c => c + "80"),
                        borderWidth: 1
                    }
                ]
            },
            options: {
                responsive: true,
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Percent (%)'
                        }
                    }
                },
                plugins: {
                    tooltip: {
                        callbacks: {
                            label: (context) => {
                                const datasetLabel = context.dataset.label;
                                const value = context.raw;
                                if (datasetLabel.includes("Posts")) {
                                    const originalValue = postValues[context.dataIndex];
                                    return `Posts: ${originalValue} (${value.toFixed(1)}% scaled)`;
                                } else {
                                    return `Election result: ${fmtPct(value)}`;
                                }
                            }
                        }
                    }
                }
            }
        });

        document.getElementById("combinedChartTitle").textContent = `3. Chart: Posts and election results together (${year})`;
    }

    function populatePartyDropdown() {
        const partyCheckboxes = document.getElementById("partyCheckboxes");
        const dropdownButton = document.getElementById("partyDropdown");
        const dropdownContent = document.getElementById("partyDropdownContent");
        const selectAllCheckbox = document.getElementById("selectAllParties");

        partyCheckboxes.innerHTML = "";

        // Get all unique parties from both years
        const parties = new Set();
        dataStore.posts2025.forEach(r => parties.add(r.party));
        dataStore.posts2021.forEach(r => parties.add(r.party));

        // Sort parties alphabetically
        const sortedParties = [...parties].sort();

        // Initialize selectedParties with no parties
        selectedParties = [];

        // Hide party charts section initially
        document.getElementById("partyChartsSection").classList.add("hidden");

        // Add checkboxes for each party
        sortedParties.forEach(party => {
            const checkboxContainer = document.createElement("div");
            checkboxContainer.className = "py-1 px-2 rounded party-checkbox-container";

            const label = document.createElement("label");
            label.className = "flex items-center cursor-pointer w-full";

            const checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.value = party;
            checkbox.checked = false; // Default: none selected
            checkbox.className = "mr-2 party-checkbox custom-checkbox";

            const span = document.createElement("span");
            span.textContent = party;

            label.appendChild(checkbox);
            label.appendChild(span);
            checkboxContainer.appendChild(label);
            partyCheckboxes.appendChild(checkboxContainer);

            // Add event listener to each checkbox
            checkbox.addEventListener("change", () => {
                updateSelectedParties();
                updateDropdownButtonText();
            });
        });

        // Toggle dropdown when button is clicked
        dropdownButton.addEventListener("click", () => {
            dropdownContent.classList.toggle("hidden");
        });

        // Close dropdown when clicking outside
        document.addEventListener("click", (e) => {
            if (!dropdownButton.contains(e.target) && !dropdownContent.contains(e.target)) {
                dropdownContent.classList.add("hidden");
            }
        });

        // Select All checkbox functionality
        selectAllCheckbox.addEventListener("change", () => {
            const isChecked = selectAllCheckbox.checked;
            document.querySelectorAll(".party-checkbox").forEach(checkbox => {
                checkbox.checked = isChecked;
            });
            updateSelectedParties();
            updateDropdownButtonText();
        });

        // Function to update selectedParties array based on checked checkboxes
        function updateSelectedParties() {
            selectedParties = [];
            document.querySelectorAll(".party-checkbox:checked").forEach(checkbox => {
                selectedParties.push(checkbox.value);
            });

            // Update "Select All" checkbox state
            const allCheckboxes = document.querySelectorAll(".party-checkbox");
            const checkedCheckboxes = document.querySelectorAll(".party-checkbox:checked");
            selectAllCheckbox.checked = allCheckboxes.length === checkedCheckboxes.length;

            // Update all charts and tables
            refresh();
        }

        // Function to update dropdown button text
        function updateDropdownButtonText() {
            const allCheckboxes = document.querySelectorAll(".party-checkbox");
            const checkedCheckboxes = document.querySelectorAll(".party-checkbox:checked");

            if (checkedCheckboxes.length === 0) {
                dropdownButton.querySelector("span").textContent = "No party";
            } else if (checkedCheckboxes.length === allCheckboxes.length) {
                dropdownButton.querySelector("span").textContent = "All parties";
            } else if (checkedCheckboxes.length === 1) {
                dropdownButton.querySelector("span").textContent = checkedCheckboxes[0].value;
            } else {
                dropdownButton.querySelector("span").textContent = `${checkedCheckboxes.length} parties`;
            }
        }
    }

    function renderPartyCharts() {
        const container = document.getElementById("partyCharts");
        container.innerHTML = "";

        // Clear existing charts
        partyCharts.forEach(chart => chart.destroy());
        partyCharts.clear();

        // If no parties selected, hide the section
        if (selectedParties.length === 0) {
            document.getElementById("partyChartsSection").classList.add("hidden");
            return;
        }

        document.getElementById("partyChartsSection").classList.remove("hidden");

        // Create a chart for each selected party
        selectedParties.forEach(party => {
            // Create container for this party's chart
            const chartContainer = document.createElement("div");
            chartContainer.className = "bg-white p-4 rounded-lg shadow";

            const chartTitle = document.createElement("h3");
            chartTitle.className = "text-lg font-semibold mb-2";
            chartTitle.textContent = party;

            const canvas = document.createElement("canvas");
            canvas.id = `chart-${party.replace(/\s+/g, '-')}`;

            chartContainer.appendChild(chartTitle);
            chartContainer.appendChild(canvas);
            container.appendChild(chartContainer);

            // Render chart for this party
            renderPartyChart(party, canvas.id);
        });
    }

    function renderPartyChart(party, canvasId) {
        const ctx = document.getElementById(canvasId).getContext("2d");

        // Get data for this party
        const data2025 = dataStore.posts2025.find(r => r.party === party);
        const data2021 = dataStore.posts2021.find(r => r.party === party);
        const election2025 = dataStore.election2025.get(party) || 0;
        const election2021 = dataStore.election2021.get(party) || 0;

        const posts2025 = data2025 ? data2025.posts : 0;
        const posts2021 = data2021 ? data2021.posts : 0;

        const partyColor = getPartyColor(party);

        const chart = new Chart(ctx, {
            type: "bar",
            data: {
                labels: ["Posts 2021", "Posts 2025", "Wahl 2021 (%)", "Wahl 2025 (%)"],
                datasets: [{
                    data: [posts2021, posts2025, election2021, election2025],
                    backgroundColor: [
                        partyColor + "80", // Posts 2021 with transparency
                        partyColor,        // Posts 2025
                        partyColor + "80", // Election 2021 with transparency
                        partyColor         // Election 2025
                    ],
                    borderColor: partyColor,
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            label: (context) => {
                                const value = context.raw;
                                const label = context.label;
                                if (label.includes("Wahl")) {
                                    return `${label}: ${fmtPct(value)}`;
                                } else {
                                    return `${label}: ${value}`;
                                }
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true
                    }
                }
            }
        });

        partyCharts.set(party, chart);
    }

    function renderScatter(rowsBoth) {
        const canvas = document.getElementById("scatterChart").getContext("2d");
        const titleEl = document.getElementById("scatterTitle");
        const scatterCard = document.getElementById("scatterCard");
        const saveBtn = document.getElementById("saveScatterBtn");
        if (scatterChart) scatterChart.destroy();

        // Filter rows based on selected parties
        const filteredRows = selectedParties.length > 0
            ? rowsBoth.filter(r => selectedParties.includes(r.party))
            : rowsBoth;

        // Punkte bauen
        const points = filteredRows.map(r => ({
            x: r.diffPosts,
            y: r.diffElection,
            r: 5,
            party: r.party,
            backgroundColor: getPartyColor(r.party),
            borderColor: getPartyColor(r.party),
        }));

        if (points.length === 0) {
            titleEl.classList.add("hidden");
            scatterCard.classList.add("hidden");
            if (saveBtn) saveBtn.classList.add("hidden");
            return;
        }
        titleEl.classList.remove("hidden");
        scatterCard.classList.remove("hidden");
        if (saveBtn) saveBtn.classList.remove("hidden");

        // Achsgrenzen mit Puffer
        const xs = points.map(p => p.x), ys = points.map(p => p.y);
        const pad = (arr, p = 0.1) => {
            const min = Math.min(...arr), max = Math.max(...arr);
            const span = max - min || 1;
            return [min - span * p, max + span * p];
        };
        const [xmin, xmax] = pad(xs, 0.15);
        const [ymin, ymax] = pad(ys, 0.15);

        scatterChart = new Chart(canvas, {
            type: "scatter",
            data: {
                datasets: [{
                    label: "Parteien",
                    data: points.map(p => ({x: p.x, y: p.y, party: p.party})),
                    pointBackgroundColor: points.map(p => p.backgroundColor),
                    pointBorderColor: points.map(p => p.borderColor),
                    pointRadius: 5,
                }]
            },
            options: {
                plugins: {
                    legend: {display: false},
                    tooltip: {
                        callbacks: {
                            label: (ctx) => {
                                const d = ctx.raw;
                                const sign = (n) => (n >= 0 ? `+${n}` : `${n}`);
                                return `${d.party}: ŒîPosts ${sign(d.x)}, ŒîElection ${sign(Number(d.y).toFixed(2))} pp`;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        title: {display: true, text: "Diff Posts (2025‚Äì2021)"},
                        min: xmin, max: xmax,
                        grid: {
                            lineWidth: (context) => context.tick.value === 0 ? 2 : 1,
                            color: (context) => context.tick.value === 0 ? '#666' : '#e5e7eb'
                        },
                        border: {
                            display: true,
                            width: 2,
                            color: '#666'
                        },
                        ticks: {precision: 0}
                    },
                    y: {
                        title: {display: true, text: "Diff Election (pp)"},
                        min: ymin, max: ymax,
                        grid: {
                            lineWidth: (context) => context.tick.value === 0 ? 2 : 1,
                            color: (context) => context.tick.value === 0 ? '#666' : '#e5e7eb'
                        },
                        border: {
                            display: true,
                            width: 2,
                            color: '#666'
                        }
                    }
                }
            }
        });
    }

    function renderPostsChartBoth() {
        const ctx = document.getElementById("pieChart").getContext("2d");
        if (pieChart) pieChart.destroy();

        const p25 = new Map((dataStore.posts2025 || []).map(r => [r.party, r.posts]));
        const p21 = new Map((dataStore.posts2021 || []).map(r => [r.party, r.posts]));

        // Get all parties that have posts in either year
        let parties = [...new Set([...p25.keys(), ...p21.keys()])];

        // Filter parties based on selection
        if (selectedParties.length > 0) {
            parties = parties.filter(party => selectedParties.includes(party));
        }

        if (parties.length === 0) return;

        const labels = parties;
        const values2025 = parties.map(p => p25.get(p) || 0);
        const values2021 = parties.map(p => p21.get(p) || 0);
        const backgroundColor = labels.map(getPartyColor);

        pieChart = new Chart(ctx, {
            type: "bar",
            data: {
                labels: labels,
                datasets: [
                    {
                        label: "Posts 2025",
                        data: values2025,
                        backgroundColor: backgroundColor,
                        borderColor: backgroundColor.map(c => c + "80"),
                        borderWidth: 1
                    },
                    {
                        label: "Posts 2021",
                        data: values2021,
                        backgroundColor: backgroundColor.map(c => c + "80"),
                        borderColor: backgroundColor,
                        borderWidth: 1
                    }
                ]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: {position: "top"},
                    tooltip: {
                        callbacks: {
                            label: (context) => {
                                return `${context.dataset.label}: ${context.raw}`;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Number of posts'
                        }
                    }
                }
            }
        });

        document.getElementById("chartTitle").textContent = "1. Chart: Posts only";
    }

    function renderElectionChartBoth() {
        const ctx = document.getElementById("electionPieChart").getContext("2d");
        if (electionPieChart) electionPieChart.destroy();

        const e25 = dataStore.election2025 || new Map();
        const e21 = dataStore.election2021 || new Map();

        // Get all parties that have election results in either year
        let parties = [...new Set([...e25.keys(), ...e21.keys()])];

        // Filter parties based on selection
        if (selectedParties.length > 0) {
            parties = parties.filter(party => selectedParties.includes(party));
        }

        if (parties.length === 0) return;

        const labels = parties;
        const values2025 = parties.map(p => e25.get(p) || 0);
        const values2021 = parties.map(p => e21.get(p) || 0);
        const backgroundColor = labels.map(getPartyColor);

        electionPieChart = new Chart(ctx, {
            type: "bar",
            data: {
                labels: labels,
                datasets: [
                    {
                        label: "Election results 2025 (%)",
                        data: values2025,
                        backgroundColor: backgroundColor,
                        borderColor: backgroundColor.map(c => c + "80"),
                        borderWidth: 1
                    },
                    {
                        label: "Election results 2021 (%)",
                        data: values2021,
                        backgroundColor: backgroundColor.map(c => c + "80"),
                        borderColor: backgroundColor,
                        borderWidth: 1
                    }
                ]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: {position: "top"},
                    tooltip: {
                        callbacks: {
                            label: (context) => {
                                return `${context.dataset.label}: ${fmtPct(context.raw)}`;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Percent (%)'
                        }
                    }
                }
            }
        });

        document.getElementById("electionChartTitle").textContent = "2. Chart: Election results only";
    }

    function refresh() {
        const subtitle = document.getElementById("subtitle");
        const scatterTitle = document.getElementById("scatterTitle");
        const scatterCard = document.getElementById("scatterCard");
        const combinedCard = document.getElementById("combinedCard");

        if (currentPeriod === "both") {
            subtitle.textContent = "View: 2025 vs. 2021";
            renderTableBoth();

            // Hide combined chart card to avoid empty white space
            if (combinedChart) {
                combinedChart.destroy();
                combinedChart = null;
            }
            combinedCard.classList.add("hidden");
            document.getElementById("combinedChartTitle").textContent = "‚Äî";
            // Show scatter card
            scatterCard.classList.remove("hidden");

            // Render posts and election charts for both years
            renderPostsChartBoth();
            renderElectionChartBoth();

            // Party charts for both years
            renderPartyCharts();
            return;
        }

        // Scatter ausblenden
        if (scatterChart) {
            scatterChart.destroy();
            scatterChart = null;
        }
        scatterTitle.classList.add("hidden");
        const saveBtn = document.getElementById("saveScatterBtn");
        if (saveBtn) saveBtn.classList.add("hidden");
        // Hide scatter card and show combined card in single-year view
        scatterCard.classList.add("hidden");
        combinedCard.classList.remove("hidden");

        const year = currentPeriod === "first" ? 2025 : 2021;
        const rows = currentPeriod === "first" ? dataStore.posts2025 : dataStore.posts2021;

        subtitle.textContent = `View: ${year}`;
        renderTableSingle(rows, year);
        renderPie(rows, year);
        renderElectionPie(year);
        renderCombinedChart(year);
        renderPartyCharts();
    }

    document.getElementById("dataset").addEventListener("change", (e) => {
        const v = e.target.value;
        currentPeriod = (v === "both") ? "both" : (v === "second" ? "second" : "first");
        refresh();
    });

    // Save scatter image handler
    const saveBtnEl = document.getElementById("saveScatterBtn");
    if (saveBtnEl) {
        saveBtnEl.addEventListener("click", saveScatterImage);
    }

    async function saveScatterImage() {
        try {
            const canvasEl = document.getElementById("scatterChart");
            if (!canvasEl || !scatterChart) {
                alert("Scatter plot is not available. Switch to 'Both elections' view first.");
                return;
            }
            const dataUrl = canvasEl.toDataURL("image/png");
            const resp = await fetch("/post-per-party/save-scatter", {
                method: "POST",
                headers: {"Content-Type": "application/json"},
                body: JSON.stringify({imageDataUrl: dataUrl})
            });
            const json = await resp.json();
            if (!resp.ok || json.status !== "ok") {
                throw new Error(json && json.message ? json.message : `HTTP ${resp.status}`);
            }
            alert("Scatter image saved to: " + json.saved);
        } catch (err) {
            console.error(err);
            alert("Failed to save image: " + err.message);
        }
    }
</script>

<!-- Patterns in the scatterplot -->
<section class="max-w-5xl mx-auto mt-6 bg-white rounded-2xl shadow p-6 space-y-3">
    <h2 class="text-xl font-semibold">Patterns in the scatterplot</h2>
    <p class="text-gray-700">A clear positive correlation between more posts and better election results cannot be confirmed.</p>
    <ul class="list-disc pl-6 text-gray-700 space-y-1">
        <li><span class="font-medium">AfD:</span> More posts ‚Üí more votes.</li>
        <li><span class="font-medium">SPD/Greens:</span> More posts ‚Üí fewer votes.</li>
        <li><span class="font-medium">CDU/CSU:</span> Fewer posts ‚Üí still gained votes.</li>
        <li><span class="font-medium">BSW:</span> Entered as a new party ‚Üí no comparison with 2021, but remarkable initial result.</li>
    </ul>
</section>

<!-- Conclusion -->
<section class="max-w-5xl mx-auto mt-6 bg-white rounded-2xl shadow p-6 space-y-3">
    <h2 class="text-xl font-semibold">Conclusion</h2>
    <p class="text-gray-700">The data suggest that the sheer number of social media posts is not a reliable predictor of electoral success.</p>
    <ul class="list-disc pl-6 text-gray-700 space-y-1">
        <li>Some parties (AfD, Left) benefited from increased activity.</li>
        <li>Others (SPD, Greens) lost votes despite more posts.</li>
        <li>CDU/CSU gained votes even with fewer posts.</li>
    </ul>
    <p class="text-gray-700">Election outcomes depend on multiple factors beyond social media activity, such as content, campaign strategy, political issues, and overall public sentiment. Social media is an important tool, but it does not guarantee success at the ballot box.</p>
</section>

{% include 'partials/footer.html' %}

<!-- Dark Mode JavaScript -->
<script>
    document.addEventListener('DOMContentLoaded', function () {
        const darkModeToggle = document.getElementById('darkModeToggle');
        const htmlElement = document.documentElement;
        const moonIcon = '<i class="fas fa-moon"></i>';
        const sunIcon = '<i class="fas fa-sun"></i>';

        // Check for saved theme preference or use system preference
        const savedTheme = localStorage.getItem('theme');
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

        // Apply the saved theme or system preference
        if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
            htmlElement.classList.add('dark');
            darkModeToggle.innerHTML = sunIcon;
        } else {
            htmlElement.classList.remove('dark');
            darkModeToggle.innerHTML = moonIcon;
        }

        // Toggle dark mode on button click
        darkModeToggle.addEventListener('click', function () {
            if (htmlElement.classList.contains('dark')) {
                htmlElement.classList.remove('dark');
                localStorage.setItem('theme', 'light');
                darkModeToggle.innerHTML = moonIcon;
            } else {
                htmlElement.classList.add('dark');
                localStorage.setItem('theme', 'dark');
                darkModeToggle.innerHTML = sunIcon;
            }
        });
    });
</script>
</body>
</html>

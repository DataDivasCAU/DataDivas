<!DOCTYPE html>
<html lang="de" class="light">
<head>
    <meta charset="UTF-8">
    <title>Anti‑Impf‑Bewegung (Antivax) – Keywords und Entwicklung</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"/>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
</head>
<body class="min-h-screen bg-gradient-to-br from-indigo-50 to-blue-100 text-gray-900">
{% include 'partials/dark_mode_toggle.html' %}

{% set page_title = 'Anti‑Impf‑Bewegung (Antivax)' %}
{% include 'partials/page_header.html' %}

<main class="max-w-5xl mx-auto p-6">
    <!-- Context text per issue description -->
    <section class="bg-white rounded-2xl shadow p-4 mb-6">
        <h2 class="text-xl font-bold mb-2">Context</h2>
        <p class="text-sm text-gray-800 mb-3">During the Covid-19-pandemic anti-vaccine conspiracy experiencend a strong growth. Especially on social media creators spread the rejection of covid-19-vaccine.
        This analysis took a look at the 10 most liked top-level-comments from all videos that deal with „anti-vaccine“ of each year. Out of these comments the top 15 keywords were found and visualized in a bar chart.</p>
        <p class="text-sm text-gray-800">In 2021 and 2022 three of the top keywords were dealing with protests and also the keyword „freedom“ occured. During these two years the protests against the lockdowns had their peak.
        In 2024 „autism“ occured in the top keywords. In this year the conspiracy theory that vaccine lead to autism was spread.</p>
    </section>

    <h2 class="text-2xl font-bold text-indigo-800 mb-4 text-center">Top Keywords nach Jahr und kombiniert</h2>
    <div class="flex items-center justify-center gap-3 mb-4">
        <label for="yearSelect" class="text-gray-700">Jahr wählen:</label>
        <select id="yearSelect" class="px-3 py-2 rounded bg-white shadow border border-gray-200"></select>
    </div>
    <div id="chartContainer" class="bg-white rounded-2xl shadow p-4">
        <canvas id="keywordsChart" height="140"></canvas>
    </div>

    <h2 class="text-2xl font-bold text-indigo-800 mt-10 mb-4 text-center">Entwicklung ausgewählter Wörter über die
        Zeit</h2>
    <div class="flex flex-col md:flex-row items-start md:items-center justify-between gap-3 mb-4">
        <!-- Multi-select dropdown -->
        <div class="relative" id="wordMultiSelect">
            <button type="button" id="wordSelectToggle"
                    class="px-3 py-2 rounded bg-white shadow border border-gray-200 flex items-center gap-2">
                <span id="wordSelectLabel">Wörter wählen</span>
                <i class="fas fa-chevron-down text-gray-500"></i>
            </button>
            <div id="wordOptions"
                 class="absolute mt-2 w-64 max-h-60 overflow-auto bg-white rounded-xl shadow-lg border border-gray-200 p-2 hidden z-20">
                <!-- options injected dynamically -->
            </div>
        </div>
        <div class="flex items-center gap-2">
            <button id="clearSelection" class="px-3 py-2 rounded bg-gray-200 hover:bg-gray-300 text-gray-800">Auswahl
                löschen
            </button>
        </div>
    </div>
    <div class="bg-white rounded-2xl shadow p-4">
        <canvas id="timeSeriesChart" height="160"></canvas>
    </div>
</main>
<script>
    document.addEventListener('DOMContentLoaded', function () {
        const htmlElement = document.documentElement;
        const darkModeToggle = document.getElementById('darkModeToggle');
        const moonIcon = '<i class="fas fa-moon"></i>';
        const sunIcon = '<i class="fas fa-sun"></i>';

        // Apply saved theme or system preference
        const savedTheme = localStorage.getItem('theme');
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
            htmlElement.classList.add('dark');
            darkModeToggle.innerHTML = sunIcon;
        } else {
            htmlElement.classList.remove('dark');
            darkModeToggle.innerHTML = moonIcon;
        }

        // Data: load from JSON file and transform to internal structure {year: [[word,count], ...]}
        const yearSelect = document.getElementById('yearSelect');
        let rawData = null; // will be { year: [[word,count], ...] }

        async function loadData() {
            try {
                const res = await fetch('/answer_one.json');
                const json = await res.json();
                // Transform: incoming format {year: { keywords: [ {words, numbers}, ... ] }}
                const transformed = {};
                Object.keys(json).forEach(year => {
                    const kwArr = (json[year] && Array.isArray(json[year].keywords)) ? json[year].keywords : (json[year] && json[year].keywords ? Object.values(json[year].keywords) : []);
                    // Map to [word, count]
                    const arr = kwArr
                        .filter(x => x && (x.words !== undefined || x.word !== undefined) && (x.numbers !== undefined || x.count !== undefined))
                        .map(x => [String(x.words ?? x.word), Number(x.numbers ?? x.count) || 0]);
                    // sort desc by count for stability
                    arr.sort((a, b) => b[1] - a[1]);
                    transformed[year] = arr;
                });
                rawData = transformed;

                // Populate selector
                const years = ['all', ...Object.keys(rawData).sort((a,b)=>a.localeCompare(b))];
                years.forEach(y => {
                    const opt = document.createElement('option');
                    opt.value = y;
                    opt.textContent = (y === 'all') ? 'Alle Jahre' : y;
                    yearSelect.appendChild(opt);
                });
                yearSelect.value = 'all';

                // proceed with rendering and controls init
                afterDataLoaded();
            } catch (e) {
                console.error('Failed to load antivax data', e);
                const container = document.getElementById('chartContainer');
                if (container) {
                    container.innerHTML = '<div class="text-red-600">Fehler beim Laden der Daten.</div>';
                }
            }
        }

        const ctx = document.getElementById('keywordsChart').getContext('2d');
        let chart;

        function getColors() {
            const isDark = htmlElement.classList.contains('dark');
            return {
                axis: isDark ? '#e2e8f0' : '#0f172a',
                grid: isDark ? '#475569' : '#e5e7eb',
                bar: '#10b981',
                lines: [
                    '#ef4444', '#3b82f6', '#22c55e', '#eab308', '#a855f7', '#06b6d4', '#f97316', '#84cc16', '#f43f5e', '#10b981'
                ],
                bg: isDark ? '#1f2937' : '#ffffff'
            };
        }

        function renderChart(year) {
            const colors = getColors();
            let labels = [];
            let data = [];
            if (year === 'all') {
                const combined = {};
                for (const yr in rawData) {
                    rawData[yr].forEach(([keyword, count]) => {
                        combined[keyword] = (combined[keyword] || 0) + count;
                    });
                }
                const sorted = Object.entries(combined).sort((a, b) => b[1] - a[1]).slice(0, 40);
                labels = sorted.map(([k]) => k);
                data = sorted.map(([_, v]) => v);
            } else {
                const yearData = rawData[year];
                labels = yearData.map(item => item[0]);
                data = yearData.map(item => item[1]);
            }
            if (chart) chart.destroy();
            chart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels,
                    datasets: [{
                        label: `Keyword frequency – ${year === 'all' ? 'Alle Jahre' : year}`,
                        data,
                        backgroundColor: colors.bar,
                        borderWidth: 1
                    }]
                },
                options: {
                    indexAxis: 'y', responsive: true,
                    plugins: {legend: {display: false}},
                    scales: {
                        x: {beginAtZero: true, ticks: {color: colors.axis}, grid: {color: colors.grid}},
                        y: {ticks: {color: colors.axis}, grid: {color: colors.grid}}
                    }
                }
            });
        }

        // defer initial render until data is loaded

        // ==== Time series for selected words ====
        const wordSelectToggle = document.getElementById('wordSelectToggle');
        const wordOptions = document.getElementById('wordOptions');
        const wordSelectLabel = document.getElementById('wordSelectLabel');
        const clearSelectionBtn = document.getElementById('clearSelection');
        const ctxTime = document.getElementById('timeSeriesChart').getContext('2d');
        let timeChart;

        // Build years sorted (initialized after data load)
        let yearLabels = [];

        // Build combined keywords and default selection (initialized after data load)
        let combinedCounts = {};
        let allKeywords = [];
        let selected = []; // default will be set after data load

        function updateSelectLabel() {
            if (selected.length === 0) {
                wordSelectLabel.textContent = 'Wörter wählen';
            } else if (selected.length <= 3) {
                wordSelectLabel.textContent = selected.join(', ');
            } else {
                wordSelectLabel.textContent = selected.slice(0, 3).join(', ') + ` +${selected.length - 3}`;
            }
        }

        function populateOptions() {
            wordOptions.innerHTML = '';
            allKeywords.forEach((kw, idx) => {
                const id = `kw_${idx}`;
                const wrap = document.createElement('label');
                wrap.className = 'flex items-center gap-2 px-2 py-1 rounded hover:bg-gray-100 cursor-pointer';
                wrap.innerHTML = `<input type="checkbox" class="kwCheck" data-kw="${kw}" ${selected.includes(kw) ? 'checked' : ''}/> <span>${kw} <span class=\"text-gray-500\">(${combinedCounts[kw]})</span></span>`;
                wordOptions.appendChild(wrap);
            });
        }

        function getDatasetFor(kw, color) {
            const data = yearLabels.map(y => {
                const entry = rawData[y].find(([k]) => k === kw);
                return entry ? entry[1] : 0;
            });
            return {
                label: kw,
                data,
                borderColor: color,
                backgroundColor: color,
                tension: 0.3,
                fill: false
            };
        }

        function renderTimeSeries() {
            const colors = getColors();
            const datasets = selected.map((kw, i) => getDatasetFor(kw, colors.lines[i % colors.lines.length]));
            if (timeChart) timeChart.destroy();
            timeChart = new Chart(ctxTime, {
                type: 'line',
                data: {labels: yearLabels, datasets},
                options: {
                    responsive: true,
                    plugins: {legend: {display: true, labels: {color: colors.axis}}},
                    scales: {
                        x: {ticks: {color: colors.axis}, grid: {color: colors.grid}},
                        y: {beginAtZero: true, ticks: {color: colors.axis}, grid: {color: colors.grid}}
                    }
                }
            });
        }

        // Initialize after data load
        function afterDataLoaded() {
            // Build years sorted from loaded rawData
            yearLabels = Object.keys(rawData).sort((a, b) => a.localeCompare(b));

            // Build combined counts
            combinedCounts = {};
            for (const y in rawData) {
                rawData[y].forEach(([k, c]) => combinedCounts[k] = (combinedCounts[k] || 0) + c);
            }
            allKeywords = Object.keys(combinedCounts).sort((a, b) => combinedCounts[b] - combinedCounts[a]);
            selected = allKeywords.slice(0, 3);

            // Initial renders
            renderChart('all');
            updateSelectLabel();
            populateOptions();
            renderTimeSeries();

            // Hook year selector now that data exists
            yearSelect.addEventListener('change', () => renderChart(yearSelect.value));
        }

        // Dropdown toggle and outside click
        wordSelectToggle.addEventListener('click', () => {
            wordOptions.classList.toggle('hidden');
        });
        document.addEventListener('click', (e) => {
            if (!document.getElementById('wordMultiSelect').contains(e.target)) {
                wordOptions.classList.add('hidden');
            }
        });

        clearSelectionBtn.addEventListener('click', () => {
            selected = [];
            populateOptions();
            updateSelectLabel();
            renderTimeSeries();
        });

        // Instant update when a checkbox is toggled
        wordOptions.addEventListener('change', (e) => {
            if (e.target && e.target.classList.contains('kwCheck')) {
                const checks = wordOptions.querySelectorAll('.kwCheck');
                selected = Array.from(checks).filter(c => c.checked).map(c => c.dataset.kw);
                updateSelectLabel();
                renderTimeSeries();
            }
        });

        // Toggle dark mode
        darkModeToggle.addEventListener('click', function () {
            if (htmlElement.classList.contains('dark')) {
                htmlElement.classList.remove('dark');
                localStorage.setItem('theme', 'light');
                darkModeToggle.innerHTML = moonIcon;
            } else {
                htmlElement.classList.add('dark');
                localStorage.setItem('theme', 'dark');
                darkModeToggle.innerHTML = sunIcon;
            }
            // Re-render if data is available
            if (rawData) {
                renderChart(yearSelect.value || 'all');
                renderTimeSeries();
            }
        });

        // Start loading data
        loadData();
    });
</script>
{% include 'partials/footer.html' %}
</body>
</html>
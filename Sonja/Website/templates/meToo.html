<!DOCTYPE html>
<html lang="de" class="light">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>#MeToo Trend & Sentiment</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"/>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nouislider@15.7.1/dist/nouislider.min.css"/>
    <script src="https://cdn.jsdelivr.net/npm/nouislider@15.7.1/dist/nouislider.min.js"></script>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
</head>
<body class="min-h-screen bg-gradient-to-br from-indigo-50 to-blue-100 text-gray-900">
{% include 'partials/dark_mode_toggle.html' %}

{% set page_title = '#MeToo Trend & Sentiment' %}
{% include 'partials/page_header.html' %}
<div class="max-w-7xl mx-auto pt-6">
    <div class="flex flex-col md:flex-row items-center gap-3 flex-wrap justify-center w-full">
        <div class="flex items-center gap-3 grow w-full md:w-auto">
            <span class="font-medium pe-2">Time period:</span>
            <div id="date-range-slider" class="w-64 md:w-96"></div>
            <div class="text-sm text-gray-600 ps-2">
                <span id="range-start" class="font-medium"></span>
                <span class="mx-1">bis</span>
                <span id="range-end" class="font-medium"></span>
            </div>
            <label for="year-select" class="ml-2 text-sm text-gray-600">Year:</label>
            <select id="year-select" class="px-2 py-2 rounded bg-gray-200 hover:bg-gray-300 text-gray-800">
                <option value="">All years</option>
            </select>
            <button id="reset-filters" class="ml-2 px-3 py-2 rounded bg-gray-200 hover:bg-gray-300 text-gray-800">
                Reset
            </button>
        </div>
    </div>
</div>
<main class="max-w-7xl mx-auto px-4 py-8 space-y-10">
    <!-- Intro: What is #MeToo? -->
    <section class="bg-white rounded-2xl shadow p-6 space-y-3">
        <h2 class="text-xl font-semibold">What is #MeToo?</h2>
        <p class="text-gray-700">#MeToo is a social and political movement that stands against sexual harassment and assault. Its primary goal is to support survivors by encouraging them to share their stories, often through social media. The widespread use of social media transformed #MeToo into a global conversation, compelling governments, political leaders, and institutions to address gender-based violence by introducing or reinforcing laws and policies aimed at prevention.</p>
    </section>

    <!-- Data gathered -->
    <section class="bg-white rounded-2xl shadow p-6 space-y-3">
        <h2 class="text-xl font-semibold">What data did we gather?</h2>
        <p class="text-gray-700">To study the movement’s impact and public engagement, we collected two types of data:</p>
        <ul class="list-disc pl-6 text-gray-700 space-y-2">
            <li>Wikipedia pageviews from the #MeToo page, covering the period from January 2016 to August 2025</li>
            <li>YouTube comments, consisting of 50 selected videos with 100 comments each sorted on relevant, allowing us to capture user sentiment and engagement in greater depth</li>
        </ul>
    </section>
    <section class="space-y-3">
        <div class="flex items-end justify-between flex-wrap gap-2">
            <div>
                <h2 class="text-lg font-semibold">Time series of Wikipedia-Pageviews</h2>
            </div>
        </div>
        <div class="bg-white rounded-2xl shadow p-4">
            <canvas id="viewsChart" height="120"></canvas>
        </div>
        <div class="bg-white rounded-2xl shadow p-4">
            <p class="text-sm text-gray-700">Graph: We created a graph that showcases the monthly pageviews of the #MeToo Wikipedia page between 01.01.2016 and 01.08.2025.</p>
        </div>
    </section>

    <section class="space-y-3">
        <div>
            <h2 class="text-lg font-semibold">Sentimentanalysis over different time periods</h2>
        </div>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div class="bg-white rounded-2xl shadow p-4">
                <h3 class="font-medium mb-2">Overall distribution</h3>
                <canvas id="sentimentPie"></canvas>
            </div>
            <div class="bg-white rounded-2xl shadow p-4">
                <h3 class="font-medium mb-2">Distribution per phase</h3>
                <canvas id="sentimentStacked"></canvas>
            </div>
        </div>
        <div class="bg-white rounded-2xl shadow p-4 space-y-3 text-sm text-gray-700">
            <p>Stacked bar plot: We created a stacked bar plot, that showcases how the (relative) sentiment changes over five different periods:</p>
            <ul class="list-disc pl-6">
                <li>01.01.2018 - 01.06.2021: Before the hype</li>
                <li>01.06.2021 - 01.01.2022: During the early hype</li>
                <li>01.01.2022 - 01.01.2023: During the peak hype</li>
                <li>01.01.2023 - 01.01.2024: During the sustained hype:</li>
                <li>after 01.01.2024: During the decline of the hype</li>
            </ul>
            <p>The sentiment was calculated using VADER, a language model specifically designed for analyzing social media and informal text. While no sentiment tool can perfectly interpret nuances such as sarcasm, VADER provides a reliable approximation of overall emotional tone, making it highly useful for tracking broad sentiment shifts over time.</p>
            <p>The pageview graph highlights fluctuations in public interest, while the sentiment analysis reveals key changes in how people responded to #MeToo. During the early to peak hype phase, positive sentiment dropped from 42% to 33%, and negative sentiment rose from 30% to 41%. The peak phase coincided with the Amber Heard case, which brought #MeToo’s core issue of survivor credibility into the spotlight and fueled widespread public debate, helping explain the sudden spike in polarized sentiment.</p>
        </div>
    </section>
</main>

{% include 'partials/footer.html' %}

<script>
    document.addEventListener('DOMContentLoaded', async () => {
        // Dark mode init (respect saved pref and system)
        const root = document.documentElement; // <html>
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)');
        const savedTheme = localStorage.getItem('theme');

        function getColors() {
            const isDark = root.classList.contains('dark');
            return {
                axis: isDark ? '#e2e8f0' : '#0f172a',
                grid: isDark ? '#475569' : '#e5e7eb',
                legend: isDark ? '#e2e8f0' : '#0f172a'
            };
        }

        function applyChartColors(chart) {
            const c = getColors();
            // default text color
            Chart.defaults.color = c.axis;
            // legend labels
            if (chart.options?.plugins?.legend?.labels) {
                chart.options.plugins.legend.labels.color = c.legend;
            } else if (chart.options?.plugins?.legend) {
                chart.options.plugins.legend.labels = { color: c.legend };
            }
            // tooltips use default; fine
            // scales
            if (chart.options?.scales) {
                Object.values(chart.options.scales).forEach(scale => {
                    if (!scale.ticks) scale.ticks = {};
                    if (!scale.grid) scale.grid = {};
                    scale.ticks.color = c.axis;
                    scale.grid.color = c.grid;
                });
            }
        }

        function applyTheme(theme) {
            if (theme === 'dark') root.classList.add('dark'); else root.classList.remove('dark');
            // Update Chart.js default color for axes/labels
            const colors = getColors();
            Chart.defaults.color = colors.axis;
            // Update existing charts if any
            window.__charts?.forEach(ch => { applyChartColors(ch); ch.update(); });
        }

        applyTheme(savedTheme ? savedTheme : (prefersDark.matches ? 'dark' : 'light'));
        prefersDark.addEventListener?.('change', e => {
            if (!localStorage.getItem('theme')) applyTheme(e.matches ? 'dark' : 'light');
        });
        const toggleBtn = document.getElementById('darkModeToggle');
        toggleBtn.addEventListener('click', () => {
            const isDark = root.classList.toggle('dark');
            localStorage.setItem('theme', isDark ? 'dark' : 'light');
            applyTheme(isDark ? 'dark' : 'light');
        });

        window.__charts = [];

        // Helper: fetch JSON with error handling
        async function getJSON(url) {
            const res = await fetch(url);
            if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
            return res.json();
        }

        // 1) Time series for views
        try {
            const series = await getJSON('/meToo_timeseries.json');
            const labels = series.map(d => d.timestamp);
            const values = series.map(d => d.views);

            const ctx1 = document.getElementById('viewsChart').getContext('2d');
            const line = new Chart(ctx1, {
                type: 'line',
                data: {
                    labels,
                    datasets: [{
                        label: 'Views',
                        data: values,
                        borderColor: '#4f46e5',
                        backgroundColor: 'rgba(79,70,229,0.12)',
                        fill: true,
                        pointRadius: 0,
                        tension: 0.15,
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {display: true},
                        tooltip: {mode: 'index', intersect: false}
                    },
                    scales: {
                        x: {ticks: {autoSkip: true, maxTicksLimit: 10}},
                        y: {beginAtZero: true}
                    }
                }
            });
            applyChartColors(line);
            window.__charts.push(line);

            // Date range slider (drag to select timeframe)
            const slider = document.getElementById('date-range-slider');
            const lblStart = document.getElementById('range-start');
            const lblEnd = document.getElementById('range-end');
            const resetBtn = document.getElementById('reset-filters');

            // Parse DD.MM.YYYY into Date
            const parseDDMMYYYY = (s) => {
                const [dd, mm, yyyy] = s.split('.');
                return new Date(Number(yyyy), Number(mm) - 1, Number(dd));
            };
            const dates = labels.map(parseDDMMYYYY);
            const minIndex = 0;
            const maxIndex = dates.length - 1;

            function fmt(d) {
                const pad = (n) => String(n).padStart(2, '0');
                return `${pad(d.getDate())}.${pad(d.getMonth() + 1)}.${d.getFullYear()}`;
            }

            if (slider && window.noUiSlider) {
                noUiSlider.create(slider, {
                    start: [minIndex, maxIndex],
                    connect: true,
                    step: 1,
                    range: {min: minIndex, max: maxIndex}
                });

                // Populate year dropdown and wire it to the slider
                const yearSelect = document.getElementById('year-select');
                const yearRanges = {};
                dates.forEach((d, i) => {
                    const y = d.getFullYear();
                    if (!(y in yearRanges)) {
                        yearRanges[y] = [i, i];
                    } else {
                        yearRanges[y][1] = i;
                    }
                });
                if (yearSelect) {
                    // Ensure options exist (keeps 'Alle Jahre' default)
                    // Remove any year options in case of re-init
                    [...yearSelect.querySelectorAll('option')]
                        .filter(o => o.value !== '')
                        .forEach(o => o.remove());
                    Object.keys(yearRanges).forEach(y => {
                        const opt = document.createElement('option');
                        opt.value = String(y);
                        opt.textContent = String(y);
                        yearSelect.appendChild(opt);
                    });

                    yearSelect.addEventListener('change', () => {
                        const val = yearSelect.value;
                        if (!val) {
                            slider.noUiSlider.set([minIndex, maxIndex]);
                            applyRange(minIndex, maxIndex);
                        } else {
                            const [a, b] = yearRanges[val];
                            slider.noUiSlider.set([a, b]);
                            applyRange(a, b);
                        }
                    });
                }

                function applyRange(iStart, iEnd) {
                    const s = Math.max(minIndex, Math.min(maxIndex, Math.round(iStart)));
                    const e = Math.max(minIndex, Math.min(maxIndex, Math.round(iEnd)));
                    const a = Math.min(s, e);
                    const b = Math.max(s, e);

                    lblStart.textContent = fmt(dates[a]);
                    lblEnd.textContent = fmt(dates[b]);

                    // Update chart with sliced data
                    const newLabels = labels.slice(a, b + 1);
                    const newValues = values.slice(a, b + 1);

                    // Reset to defaults
                    line.data.datasets[0].pointRadius = 0;
                    line.options.scales.x.ticks.autoSkip = true;
                    line.options.scales.x.ticks.maxTicksLimit = 10;

                    line.data.labels = newLabels;
                    line.data.datasets[0].data = newValues;
                    line.update();
                }

                slider.noUiSlider.on('update', (valuesArr) => {
                    // Only update labels on move
                    const iStart = Number(valuesArr[0]);
                    const iEnd = Number(valuesArr[1]);
                    const s = Math.round(iStart);
                    const e = Math.round(iEnd);
                    lblStart.textContent = fmt(dates[Math.min(s, e)]);
                    lblEnd.textContent = fmt(dates[Math.max(s, e)]);
                });

                slider.noUiSlider.on('change', (valuesArr) => {
                    const iStart = Number(valuesArr[0]);
                    const iEnd = Number(valuesArr[1]);
                    applyRange(iStart, iEnd);
                });

                // Initial apply full range
                applyRange(minIndex, maxIndex);

                // Reset button returns to full range
                resetBtn?.addEventListener('click', () => {
                    slider.noUiSlider.set([minIndex, maxIndex]);
                    applyRange(minIndex, maxIndex);
                    if (typeof yearSelect !== 'undefined' && yearSelect) {
                        yearSelect.value = '';
                    }
                });
            }
        } catch (e) {
            console.error('Fehler beim Laden der Zeitreihe', e);
        }

        // 2) Sentiment
        try {
            const s = await getJSON('/meToo_sentiment.json');
            const phases = Object.keys(s);
            const categories = ['positive', 'neutral', 'negative'];

            // Aggregate totals
            const totals = categories.map(cat => phases.reduce((acc, ph) => acc + (s[ph][cat] || 0), 0));

            // Pie chart
            const ctxPie = document.getElementById('sentimentPie').getContext('2d');
            const pie = new Chart(ctxPie, {
                type: 'doughnut',
                data: {
                    labels: ['Positiv', 'Neutral', 'Negativ'],
                    datasets: [{
                        data: totals,
                        backgroundColor: ['#10b981', '#94a3b8', '#ef4444']
                    }]
                },
                options: {plugins: {legend: {position: 'bottom'}}}
            });
            applyChartColors(pie);
            window.__charts.push(pie);

            // Stacked bar per phase
            const ctxStack = document.getElementById('sentimentStacked').getContext('2d');
            // Convert absolute counts to percentages per phase
            const phaseLabels = phases.map(p => p.replace('sentiment', '').replace(/([A-Z])/g, ' $1').trim());
            const totalsPerPhase = phases.map(p => {
                const pos = Number(s[p].positive || 0);
                const neu = Number(s[p].neutral || 0);
                const neg = Number(s[p].negative || 0);
                const t = pos + neu + neg;
                return t > 0 ? t : 0;
            });
            const toPct = (val, total) => total ? +(val / total * 100).toFixed(2) : 0;
            const dataPos = phases.map((p, i) => toPct(Number(s[p].positive || 0), totalsPerPhase[i]));
            const dataNeu = phases.map((p, i) => toPct(Number(s[p].neutral || 0), totalsPerPhase[i]));
            const dataNeg = phases.map((p, i) => toPct(Number(s[p].negative || 0), totalsPerPhase[i]));

            const bar = new Chart(ctxStack, {
                type: 'bar',
                data: {
                    labels: phaseLabels,
                    datasets: [
                        {label: 'Positiv', backgroundColor: '#10b981', data: dataPos},
                        {label: 'Neutral', backgroundColor: '#94a3b8', data: dataNeu},
                        {label: 'Negativ', backgroundColor: '#ef4444', data: dataNeg}
                    ]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {position: 'bottom'},
                        tooltip: {
                            callbacks: {
                                label: (ctx) => {
                                    const label = ctx.dataset.label || '';
                                    const v = typeof ctx.raw === 'number' ? ctx.raw : Number(ctx.raw);
                                    return `${label}: ${v}%`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {stacked: true},
                        y: {
                            stacked: true,
                            beginAtZero: true,
                            max: 100,
                            ticks: {
                                callback: (value) => `${value}%`
                            }
                        }
                    }
                }
            });
            applyChartColors(bar);
            window.__charts.push(bar);
        } catch (e) {
            console.error('Fehler beim Laden des Sentiments', e);
        }
    });
</script>
</body>
</html>
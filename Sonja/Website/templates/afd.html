<!DOCTYPE html>
<html lang="de" class="light">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>AfD – Social Media Analysis</title>
    <script src="https://cdn.tailwindcss.com" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js" defer></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"/>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nouislider@15.7.1/dist/nouislider.min.css"/>
    <script src="https://cdn.jsdelivr.net/npm/nouislider@15.7.1/dist/nouislider.min.js" defer></script>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
    <style>
        .chart-box {
            background: white;
            border-radius: 1rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.06);
            padding: 1rem;
        }

        .dark .chart-box {
            background: #111827;
        }
    </style>
    <link rel="icon" type="image/png" href="{{ url_for('favicon') }}">
</head>
<body class="min-h-screen bg-gradient-to-br from-indigo-50 to-blue-100 text-gray-900">
{% include 'partials/dark_mode_toggle.html' %}

{% set page_title = 'AfD – Social Media Analysis' %}
{% include 'partials/page_header.html' %}

<main class="max-w-7xl mx-auto p-6">
    <!-- Intro: place text inside a card like on tradwife page -->
    <section class="mt-4 mb-8 bg-white rounded-2xl shadow p-6 space-y-3">
        <h2 class="text-xl font-semibold">Introduction</h2>
        <p class="text-gray-700">During election periods, political parties often experience shifts in public attention across multiple online platforms. These shifts can be measured through both user-driven activity, such as Wikipedia pageviews, and content production, such as uploads on YouTube. Examining the relationship between these forms of online engagement provides insight into how online political visibility is influenced by different factors.</p>
        <h3 class="font-medium">What Data did we collect?</h3>
        <p class="text-gray-700">We collected a sample size of ~1000 Videos uploaded on YouTube and the Number of WikiPedia Pageviews on the ‘Alternative für Deutschland’ Wikipedia Page in the Time period between November 2024 and February 2025, just before the most recent German federal Elections.</p>
        <h3 class="font-medium">Line-Charts:</h3>
        <p class="text-gray-700">We grouped the YouTube video uploads by day/week and collected daily/weekly Wikipedia Pageviews to then convert them into percentages relative to the total uploads/views in the observed period. Both relative values are mapped in this bar chart.</p>
        <h3 class="font-medium">Scatter Plots:</h3>
        <p class="text-gray-700">We mapped both relative values – YouTube video uploads and Wikipedia page views – in this chart. This chart shows the correlation between both relative values.</p>
    </section>
    <div class="flex items-center gap-3 flex-wrap justify-center w-full mb-6">
        <div class="flex items-center gap-3 grow w-full md:w-auto">
            <span class="font-medium pe-2">Time period:</span>
            <div id="date-range-slider" class="w-64 md:w-96"></div>
            <div class="text-sm text-gray-600 ps-2">
                <span id="range-start" class="font-medium"></span>
                <span class="mx-1">until</span>
                <span id="range-end" class="font-medium"></span>
            </div>
            <label for="year-select" class="ml-2 text-sm text-gray-600">Year:</label>
            <select id="year-select" class="px-2 py-2 rounded bg-gray-200 hover:bg-gray-300 text-gray-800">
                <option value="">Every year</option>
            </select>
            <button id="reset-filters" class="ml-2 px-3 py-2 rounded bg-gray-200 hover:bg-gray-300 text-gray-800">
                Reset
            </button>
        </div>
    </div>

    <section class="grid gap-6 md:grid-cols-2 mb-8">
        <div class="chart-box">
            <h2 class="text-lg font-semibold mb-2 text-center">Correlation: Videos vs. Wikipedia‑Pageviews
                (relative)</h2>
            <canvas id="scatterCombined" height="160"></canvas>
        </div>
        <div class="chart-box">
            <h2 class="text-lg font-semibold mb-2 text-center">Time series (weekly, absolute)</h2>
            <canvas id="lineWeekly" height="260"></canvas>
        </div>
    </section>

    <section class="mb-8">
        <div class="chart-box">
            <h2 class="text-lg font-semibold mb-2 text-center">Time series (daily, relative)</h2>
            <canvas id="lineDaily" height="280"></canvas>
        </div>
    </section>

    <!-- Conclusion: card styling analogous to tradwife page -->
    <section class="mt-8 mb-8 bg-white rounded-2xl shadow p-6 space-y-3">
        <h2 class="text-xl font-semibold">Conclusion</h2>
        <p class="text-gray-700">During the most recent German federal elections, the data shows that Wikipedia pageviews about the AfD spiked at certain points. These spikes moderately aligned with increases in YouTube video uploads about the party. This is also reflected by a Pearson correlation of 0.49.</p>
        <p class="text-gray-700">Suggesting that while public interest in information and content production on YouTube are connected, the relationship is not strong enough to imply direct causation.</p>
        <p class="text-gray-700">Instead, the results suggest that both are likely influenced by the same factors, such as growing public attention and media coverage during important campaign moments.</p>
        <p class="text-gray-700">Overall, the results highlight that online attention toward the AfD comes from many different sides, with different platforms reflecting related but distinct patterns of engagement during electoral periods.</p>
    </section>

</main>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const htmlEl = document.documentElement;
        const darkModeToggle = document.getElementById('darkModeToggle');
        const moonIcon = '<i class="fas fa-moon"></i>';
        const sunIcon = '<i class="fas fa-sun"></i>';

        const gradientClasses = ['bg-gradient-to-br', 'from-indigo-50', 'to-blue-100'];

        function applyTheme(isDark) {
            if (isDark) {
                htmlEl.classList.add('dark');
                darkModeToggle.innerHTML = sunIcon;
                document.body.classList.add('bg-gray-900', 'text-gray-100');
                gradientClasses.forEach(c => document.body.classList.remove(c));
            } else {
                htmlEl.classList.remove('dark');
                darkModeToggle.innerHTML = moonIcon;
                document.body.classList.remove('bg-gray-900', 'text-gray-100');
                gradientClasses.forEach(c => document.body.classList.add(c));
            }
        }

        const savedTheme = localStorage.getItem('theme');
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        const isDarkInit = (savedTheme === 'dark' || (!savedTheme && prefersDark));
        applyTheme(isDarkInit);

        function whenChartReady(cb) {
            if (window.Chart) return cb();
            window.addEventListener('load', () => cb());
        }

        darkModeToggle.addEventListener('click', () => {
            const isDark = !htmlEl.classList.contains('dark');
            localStorage.setItem('theme', isDark ? 'dark' : 'light');
            applyTheme(isDark);
            // Recolor charts once Chart.js is ready
            whenChartReady(() => renderAll());
        });

        const scatterCtx = document.getElementById('scatterCombined').getContext('2d');
        const lineCtx = document.getElementById('lineDaily').getContext('2d');
        const weeklyCtx = document.getElementById('lineWeekly').getContext('2d');

        let scatterChart, lineChart, weeklyChart;
        let combined = [];
        let daily = [];
        let wikiWeekly = [];
        let ytWeekly = [];
        let wikiDaily = [];
        let dailySorted = [];
        let dateLabels = [];
        let slider, lblStart, lblEnd, yearSelect, resetBtn;
        let currentRange = null; // [startIdx, endIdx]
        let yearRanges = {};

        function getAxis() {
            return htmlEl.classList.contains('dark') ? '#e2e8f0' : '#0f172a';
        }

        function getGrid() {
            return htmlEl.classList.contains('dark') ? '#374151' : '#e5e7eb';
        }

        function renderScatter() {
            // Use currently filtered daily subset and compute relative percentages per selected range
            const subset = getFilteredDaily();
            const vids = subset.map(d => Number(d['Number of Videos'] || 0));
            const wikis = subset.map(d => Number(d['Wikipedia Pageviews'] || 0));
            const sumV = vids.reduce((a, b) => a + (Number.isFinite(b) ? b : 0), 0);
            const sumW = wikis.reduce((a, b) => a + (Number.isFinite(b) ? b : 0), 0);

            const safeDiv = (num, den) => den > 0 ? (num / den) * 100 : 0;
            const points = subset.map((_, i) => ({
                x: safeDiv(vids[i], sumV),
                y: safeDiv(wikis[i], sumW)
            })).filter(p => Number.isFinite(p.x) && Number.isFinite(p.y));

            // Compute linear regression (least squares) on relative points
            let trendData = [];
            if (points.length >= 2) {
                const n = points.length;
                let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
                let minX = Infinity, maxX = -Infinity;
                points.forEach(p => {
                    const x = p.x, y = p.y;
                    sumX += x;
                    sumY += y;
                    sumXY += x * y;
                    sumXX += x * x;
                    if (x < minX) minX = x;
                    if (x > maxX) maxX = x;
                });
                const denom = (n * sumXX - sumX * sumX);
                if (denom !== 0) {
                    const b = (n * sumXY - sumX * sumY) / denom; // slope
                    const a = (sumY - b * sumX) / n;            // intercept
                    const y1 = a + b * minX;
                    const y2 = a + b * maxX;
                    if (Number.isFinite(y1) && Number.isFinite(y2)) {
                        trendData = [{x: minX, y: y1}, {x: maxX, y: y2}];
                    }
                }
            }

            if (scatterChart) scatterChart.destroy();
            const datasets = [
                {label: 'Points', data: points, backgroundColor: '#10b981', pointRadius: 4}
            ];
            if (trendData.length === 2) {
                datasets.push({
                    label: 'Trendline',
                    type: 'line',
                    data: trendData,
                    borderColor: '#0ea5e9',
                    borderWidth: 2,
                    pointRadius: 0,
                    fill: false,
                    tension: 0
                });
            }
            scatterChart = new Chart(scatterCtx, {
                type: 'scatter',
                data: {datasets},
                options: {
                    scales: {
                        x: {
                            title: {display: true, text: 'Video count (relative, %)'},
                            ticks: {color: getAxis()},
                            grid: {color: getGrid()}
                        },
                        y: {
                            title: {display: true, text: 'Wikipedia-Pageviews (relative, %)'},
                            ticks: {color: getAxis()},
                            grid: {color: getGrid()}
                        }
                    },
                    plugins: {legend: {display: true}}
                }
            });
        }

        function getFilteredDaily() {
            const src = dailySorted;
            if (!currentRange) return src;
            const [s, e] = currentRange;
            return src.slice(s, e + 1);
        }

        function getRangeDates() {
            if (!currentRange || !dateLabels?.length) return null;
            const [s, e] = currentRange;
            const start = dateLabels[Math.max(0, Math.min(s, dateLabels.length - 1))];
            const end = dateLabels[Math.max(0, Math.min(e, dateLabels.length - 1))];
            return [start, end];
        }

        function renderLine() {
            const subset = getFilteredDaily();
            const labels = subset.map(d => new Date(Number(d['Published At'])).toISOString().slice(0, 10));
            const videos = subset.map(d => Number(d['Number of Videos'] || 0));
            const wiki = subset.map(d => Number(d['Wikipedia Pageviews'] || 0));
            if (lineChart) lineChart.destroy();
            lineChart = new Chart(lineCtx, {
                type: 'line',
                data: {
                    labels,
                    datasets: [
                        {
                            label: 'Videos (rel.)',
                            data: videos,
                            borderColor: '#10b981',
                            backgroundColor: 'rgba(16,185,129,0.2)',
                            tension: 0.2,
                            fill: true,
                            yAxisID: 'y1'
                        },
                        {
                            label: 'Wikipedia (rel.)',
                            data: wiki,
                            borderColor: '#ef4444',
                            backgroundColor: 'rgba(239,68,68,0.2)',
                            tension: 0.2,
                            fill: true,
                            yAxisID: 'y'
                        }
                    ]
                },
                options: {
                    scales: {
                        x: { 
                            title: { display: true, text: 'Date' },
                            ticks: {color: getAxis()}, grid: {color: getGrid()}
                        },
                        y: { 
                            type: 'linear', position: 'left',
                            title: { display: true, text: 'Wikipedia (relative, %)' },
                            ticks: {color: getAxis()}, grid: {color: getGrid()}
                        },
                        y1: {
                            type: 'linear',
                            position: 'right',
                            title: { display: true, text: 'Videos (relative, %)' },
                            ticks: {color: getAxis()},
                            grid: {drawOnChartArea: false}
                        }
                    }
                }
            });
        }


        function renderWeekly() {
            // Build weekly aligned labels, filtered by current date range if set
            const labels = [];
            const range = getRangeDates();
            const ytSrc = range ? ytWeekly.filter(d => d._date >= range[0] && d._date <= range[1]) : ytWeekly;
            const wkSrc = range ? wikiWeekly.filter(d => d._date >= range[0] && d._date <= range[1]) : wikiWeekly;
            const ytMap = new Map(ytSrc.map(d => [d._dateStr, Number(d['Number of Videos'])]));
            const wkMap = new Map(wkSrc.map(d => [d._dateStr, Number(d._value)]));
            const allKeys = new Set([...ytMap.keys(), ...wkMap.keys()]);
            const sortedKeys = [...allKeys].sort();
            const ytSeries = [];
            const wkSeries = [];
            sortedKeys.forEach(k => {
                labels.push(k);
                ytSeries.push(ytMap.get(k) ?? 0);
                wkSeries.push(wkMap.get(k) ?? 0);
            });
            if (weeklyChart) weeklyChart.destroy();
            weeklyChart = new Chart(weeklyCtx, {
                type: 'line',
                data: {
                    labels,
                    datasets: [
                        {
                            label: 'YouTube: Videos (weekly)',
                            data: ytSeries,
                            borderColor: '#10b981',
                            backgroundColor: 'rgba(16,185,129,0.2)',
                            tension: 0.2,
                            fill: true
                        },
                        {
                            label: 'Wikipedia: Pageviews (weekly)',
                            data: wkSeries,
                            borderColor: '#ef4444',
                            backgroundColor: 'rgba(239,68,68,0.2)',
                            tension: 0.2,
                            fill: true
                        }
                    ]
                },
                options: {
                    scales: {
                        x: {
                            title: { display: true, text: 'Date' },
                            ticks: {color: getAxis()}, grid: {color: getGrid()}
                        },
                        y: {
                            title: { display: true, text: 'Weekly value' },
                            ticks: {color: getAxis()}, grid: {color: getGrid()}
                        }
                    }
                }
            });
        }


        function renderAll() {
            renderScatter();
            renderLine();
            renderWeekly();
        }

        function fmtDate(d) {
            const pad = (n) => String(n).padStart(2, '0');
            return `${pad(d.getDate())}.${pad(d.getMonth() + 1)}.${d.getFullYear()}`;
        }

        function initFilters() {
            dailySorted = [...daily].sort((a, b) => Number(a['Published At']) - Number(b['Published At']));
            dateLabels = dailySorted.map(d => new Date(Number(d['Published At'])));
            const minIndex = 0;
            const maxIndex = dateLabels.length - 1;
            currentRange = [minIndex, maxIndex];

            slider = document.getElementById('date-range-slider');
            lblStart = document.getElementById('range-start');
            lblEnd = document.getElementById('range-end');
            yearSelect = document.getElementById('year-select');
            resetBtn = document.getElementById('reset-filters');

            if (slider && window.noUiSlider) {
                if (slider.noUiSlider) {
                    slider.noUiSlider.destroy();
                }
                noUiSlider.create(slider, {
                    start: [minIndex, maxIndex],
                    connect: true,
                    step: 1,
                    range: {min: minIndex, max: maxIndex}
                });
                const updateLabels = (s, e) => {
                    lblStart.textContent = fmtDate(dateLabels[s]);
                    lblEnd.textContent = fmtDate(dateLabels[e]);
                };
                updateLabels(minIndex, maxIndex);
                slider.noUiSlider.on('update', (values) => {
                    const s = Math.round(Number(values[0]));
                    const e = Math.round(Number(values[1]));
                    currentRange = [s, e];
                    updateLabels(s, e);
                    renderLine();
                    renderWeekly();
                    renderScatter();
                });
            }

            // Build year ranges and dropdown
            yearRanges = {};
            dateLabels.forEach((d, i) => {
                const y = d.getFullYear();
                if (!(y in yearRanges)) yearRanges[y] = [i, i]; else yearRanges[y][1] = i;
            });
            if (yearSelect) {
                // remove existing year options except "" (Alle Jahre)
                [...yearSelect.querySelectorAll('option')].filter(o => o.value !== '').forEach(o => o.remove());
                Object.keys(yearRanges).forEach(y => {
                    const opt = document.createElement('option');
                    opt.value = String(y);
                    opt.textContent = String(y);
                    yearSelect.appendChild(opt);
                });
                yearSelect.addEventListener('change', () => {
                    const val = yearSelect.value;
                    if (!val) {
                        if (slider?.noUiSlider) {
                            slider.noUiSlider.set([minIndex, maxIndex]);
                        }
                        currentRange = [minIndex, maxIndex];
                        renderLine();
                        renderWeekly();
                        renderScatter();
                    } else {
                        const [s, e] = yearRanges[val];
                        currentRange = [s, e];
                        if (slider?.noUiSlider) {
                            slider.noUiSlider.set([s, e]);
                        }
                        renderLine();
                        renderWeekly();
                        renderScatter();
                    }
                });
            }

            if (resetBtn) {
                resetBtn.addEventListener('click', () => {
                    if (yearSelect) yearSelect.value = '';
                    const minIndexR = 0, maxIndexR = dateLabels.length - 1;
                    currentRange = [minIndexR, maxIndexR];
                    if (slider?.noUiSlider) {
                        slider.noUiSlider.set([minIndexR, maxIndexR]);
                    }
                    renderLine();
                    renderWeekly();
                    renderScatter();
                });
            }
        }

        Promise.all([
            fetch('/afd_wiki.json').then(r => r.json()),
            fetch('/afd_yt.json').then(r => r.json()),
            fetch('/afd_wiki_daily.json').then(r => r.json()),
            fetch('/afd_yt_daily.json').then(r => r.json()),
        ]).then(([wikiWeeklyJson, ytWeeklyJson, wikiDailyJson, ytDailyJson]) => {
            // Parse wiki weekly
            wikiWeekly = (Array.isArray(wikiWeeklyJson) ? wikiWeeklyJson : []).map(r => {
                // source has date under empty key "" and value under "Alternative_für_Deutschland"
                const dateStr = (r[""] || r.date || r.Date || r.Datum || '').toString();
                const d = new Date(dateStr);
                return {
                    _date: d,
                    _dateStr: d.toISOString().slice(0, 10),
                    _value: Number(r['Alternative_für_Deutschland'] || 0)
                };
            }).filter(x => !isNaN(x._date.getTime()));
            // Parse yt weekly (already with proper keys)
            ytWeekly = (Array.isArray(ytWeeklyJson) ? ytWeeklyJson : []).map(r => {
                const raw = String(r['Published At'] || '');
                const iso = raw.includes('T') ? raw : raw.replace(' ', 'T');
                const d = new Date(iso);
                return {
                    _date: d,
                    _dateStr: isNaN(d.getTime()) ? '' : d.toISOString().slice(0, 10),
                    'Number of Videos': Number(r['Number of Videos'] || 0)
                };
            }).filter(r => r._dateStr);

            // Parse wiki daily
            wikiDaily = (Array.isArray(wikiDailyJson) ? wikiDailyJson : []).map(r => {
                const dateStr = (r[""] || r.date || '').toString();
                const d = new Date(dateStr);
                return {
                    _date: d,
                    _dateStr: d.toISOString().slice(0, 10),
                    _value: Number(r['Alternative_für_Deutschland'] || 0)
                };
            }).filter(x => !isNaN(x._date.getTime()));
            // Parse yt daily
            const ytDaily = (Array.isArray(ytDailyJson) ? ytDailyJson : []).map(r => {
                const raw = String(r['Published At'] || '');
                const iso = raw.includes('T') ? raw : raw.replace(' ', 'T');
                const d = new Date(iso);
                return {
                    _date: d,
                    _dateStr: isNaN(d.getTime()) ? '' : d.toISOString().slice(0, 10),
                    _value: Number(r['Number of Videos'] || 0)
                };
            }).filter(x => x._dateStr);

            // Build combined weekly points by aligning dates
            const ytWkMap = new Map(ytDaily.map(d => [d._dateStr, d['Number of Videos']]));
            const wkWkMap = new Map(wikiDaily.map(d => [d._dateStr, d._value]));
            // Use union of weeks and fill missing values with 0 so we don't drop points
            const wkAllKeys = [...new Set([...ytWkMap.keys(), ...wkWkMap.keys()])].sort();
            combined = wkAllKeys.map(k => ({
                'Number of Videos': ytWkMap.get(k) ?? 0,
                'Wikipedia Pageviews': wkWkMap.get(k) ?? 0
            }));

            // Build daily combined array expected by charts
            const ytDailyMap = new Map(ytDaily.map(d => [d._dateStr, d._value]));
            const wkDailyMap = new Map(wikiDaily.map(d => [d._dateStr, d._value]));
            const dailyKeys = [...new Set([...ytDailyMap.keys(), ...wkDailyMap.keys()])].sort();
            daily = dailyKeys.map(k => ({
                'Published At': new Date(k).getTime(),
                'Number of Videos': ytDailyMap.get(k) ?? 0,
                'Wikipedia Pageviews': wkDailyMap.get(k) ?? 0
            }));

            // Init controls for daily combined series
            initFilters();
            whenChartReady(() => renderAll());
        }).catch(err => {
            console.error('Fehler beim Laden der AfD-Daten', err);
        });
    });
</script>
{% include 'partials/footer.html' %}
</body>
</html>

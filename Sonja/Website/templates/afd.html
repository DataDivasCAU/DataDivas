<!DOCTYPE html>
<html lang="de" class="light">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AfD – Social Media Analyse</title>
  <script src="https://cdn.tailwindcss.com" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js" defer></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nouislider@15.7.1/dist/nouislider.min.css" />
  <script src="https://cdn.jsdelivr.net/npm/nouislider@15.7.1/dist/nouislider.min.js" defer></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
  <style>
    .chart-box { background: white; border-radius: 1rem; box-shadow: 0 10px 25px rgba(0,0,0,0.06); padding: 1rem; }
    .dark .chart-box { background: #111827; }
  </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-indigo-50 to-blue-100 text-gray-900">
{% include 'partials/dark_mode_toggle.html' %}

{% set page_title = 'AfD – Social Media Analyse' %}
{% set page_subtitle = 'Datenbasis: afd_wiki.json, afd_yt.json, afd_wiki_daily.json, afd_yt_daily.json' %}
{% include 'partials/page_header.html' %}

<main class="max-w-5xl mx-auto p-6">
  <div class="flex items-center gap-3 flex-wrap justify-center w-full mb-6">
    <div class="flex items-center gap-3 grow w-full md:w-auto">
      <span class="font-medium pe-2">Zeitraum:</span>
      <div id="date-range-slider" class="w-64 md:w-96"></div>
      <div class="text-sm text-gray-600 ps-2">
        <span id="range-start" class="font-medium"></span>
        <span class="mx-1">bis</span>
        <span id="range-end" class="font-medium"></span>
      </div>
      <label for="year-select" class="ml-2 text-sm text-gray-600">Jahr:</label>
      <select id="year-select" class="px-2 py-2 rounded bg-gray-200 hover:bg-gray-300 text-gray-800">
        <option value="">Alle Jahre</option>
      </select>
      <button id="reset-filters" class="ml-2 px-3 py-2 rounded bg-gray-200 hover:bg-gray-300 text-gray-800">Zurücksetzen</button>
    </div>
  </div>

  <section class="grid gap-6 md:grid-cols-2 mb-8">
    <div class="chart-box">
      <h2 class="text-lg font-semibold mb-2 text-center">Zusammenhang: Videos vs. Wikipedia‑Seitenaufrufe (relativ)</h2>
      <canvas id="scatterCombined" height="160"></canvas>
    </div>
    <div class="chart-box">
      <h2 class="text-lg font-semibold mb-2 text-center">Zeitverlauf (wöchentlich, absolut)</h2>
      <canvas id="lineWeekly" height="260"></canvas>
    </div>
  </section>

  <section class="mb-8">
    <div class="chart-box">
      <h2 class="text-lg font-semibold mb-2 text-center">Zeitverlauf (täglich, relativ)</h2>
      <canvas id="lineDaily" height="280"></canvas>
    </div>
  </section>

</main>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const htmlEl = document.documentElement;
    const darkModeToggle = document.getElementById('darkModeToggle');
    const moonIcon = '<i class="fas fa-moon"></i>';
    const sunIcon = '<i class="fas fa-sun"></i>';

    const gradientClasses = ['bg-gradient-to-br','from-indigo-50','to-blue-100'];
    function applyTheme(isDark){
      if (isDark){
        htmlEl.classList.add('dark');
        darkModeToggle.innerHTML = sunIcon;
        document.body.classList.add('bg-gray-900','text-gray-100');
        gradientClasses.forEach(c => document.body.classList.remove(c));
      } else {
        htmlEl.classList.remove('dark');
        darkModeToggle.innerHTML = moonIcon;
        document.body.classList.remove('bg-gray-900','text-gray-100');
        gradientClasses.forEach(c => document.body.classList.add(c));
      }
    }
    const savedTheme = localStorage.getItem('theme');
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    const isDarkInit = (savedTheme === 'dark' || (!savedTheme && prefersDark));
    applyTheme(isDarkInit);

    function whenChartReady(cb){
      if (window.Chart) return cb();
      window.addEventListener('load', () => cb());
    }

    darkModeToggle.addEventListener('click', () => {
      const isDark = !htmlEl.classList.contains('dark');
      localStorage.setItem('theme', isDark ? 'dark' : 'light');
      applyTheme(isDark);
      // Recolor charts once Chart.js is ready
      whenChartReady(() => renderAll());
    });

    const scatterCtx = document.getElementById('scatterCombined').getContext('2d');
    const lineCtx = document.getElementById('lineDaily').getContext('2d');
    const weeklyCtx = document.getElementById('lineWeekly').getContext('2d');

    let scatterChart, lineChart, weeklyChart;
    let combined = [];
    let daily = [];
    let wikiWeekly = [];
    let ytWeekly = [];
    let wikiDaily = [];
    let dailySorted = [];
    let dateLabels = [];
    let slider, lblStart, lblEnd, yearSelect, resetBtn;
    let currentRange = null; // [startIdx, endIdx]
    let yearRanges = {};

    function getAxis(){ return htmlEl.classList.contains('dark') ? '#e2e8f0' : '#0f172a'; }
    function getGrid(){ return htmlEl.classList.contains('dark') ? '#374151' : '#e5e7eb'; }

    function renderScatter(){
      const points = combined.map(d=>({
        x: Number(d['Number of Videos']||0),
        y: Number(d['Wikipedia Pageviews']||0)
      })).filter(p=> Number.isFinite(p.x) && Number.isFinite(p.y));

      // Compute linear regression (least squares)
      let trendData = [];
      if (points.length >= 2){
        const n = points.length;
        let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
        let minX = Infinity, maxX = -Infinity;
        points.forEach(p=>{
          const x = p.x, y = p.y;
          sumX += x; sumY += y; sumXY += x*y; sumXX += x*x;
          if (x < minX) minX = x;
          if (x > maxX) maxX = x;
        });
        const denom = (n*sumXX - sumX*sumX);
        if (denom !== 0){
          const b = (n*sumXY - sumX*sumY) / denom; // slope
          const a = (sumY - b*sumX) / n;            // intercept
          const y1 = a + b*minX;
          const y2 = a + b*maxX;
          if (Number.isFinite(y1) && Number.isFinite(y2)){
            trendData = [{ x: minX, y: y1 }, { x: maxX, y: y2 }];
          }
        }
      }

      if (scatterChart) scatterChart.destroy();
      const datasets = [
        { label: 'Punkte', data: points, backgroundColor: '#10b981', pointRadius: 4 }
      ];
      if (trendData.length === 2){
        datasets.push({
          label: 'Trendlinie',
          type: 'line',
          data: trendData,
          borderColor: '#0ea5e9',
          borderWidth: 2,
          pointRadius: 0,
          fill: false,
          tension: 0
        });
      }
      scatterChart = new Chart(scatterCtx, {
        type: 'scatter',
        data: { datasets },
        options: {
          scales: {
            x: { title: { display: true, text: 'Anzahl Videos (relativ)' }, ticks: { color: getAxis() }, grid: { color: getGrid() } },
            y: { title: { display: true, text: 'Wikipedia‑Seitenaufrufe (relativ)' }, ticks: { color: getAxis() }, grid: { color: getGrid() } }
          },
          plugins: { legend: { display: true } }
        }
      });
    }

    function getFilteredDaily(){
      const src = dailySorted;
      if (!currentRange) return src;
      const [s,e] = currentRange;
      return src.slice(s, e+1);
    }

    function getRangeDates(){
      if (!currentRange || !dateLabels?.length) return null;
      const [s,e] = currentRange;
      const start = dateLabels[Math.max(0, Math.min(s, dateLabels.length-1))];
      const end = dateLabels[Math.max(0, Math.min(e, dateLabels.length-1))];
      return [start, end];
    }

    function renderLine(){
      const subset = getFilteredDaily();
      const labels = subset.map(d=> new Date(Number(d['Published At'])).toISOString().slice(0,10));
      const videos = subset.map(d=> Number(d['Number of Videos']||0));
      const wiki = subset.map(d=> Number(d['Wikipedia Pageviews']||0));
      if (lineChart) lineChart.destroy();
      lineChart = new Chart(lineCtx, {
        type: 'line',
        data: {
          labels,
          datasets: [
            { label: 'Videos (rel.)', data: videos, borderColor: '#3b82f6', backgroundColor: 'rgba(59,130,246,0.2)', tension: 0.2, fill: true, yAxisID: 'y1' },
            { label: 'Wikipedia (rel.)', data: wiki, borderColor: '#ef4444', backgroundColor: 'rgba(239,68,68,0.2)', tension: 0.2, fill: true, yAxisID: 'y' }
          ]
        },
        options: {
          scales: {
            x: { ticks: { color: getAxis() }, grid: { color: getGrid() } },
            y: { type: 'linear', position: 'left', ticks: { color: getAxis() }, grid: { color: getGrid() } },
            y1: { type: 'linear', position: 'right', ticks: { color: getAxis() }, grid: { drawOnChartArea: false } }
          }
        }
      });
    }


    function renderWeekly(){
      // Build weekly aligned labels, filtered by current date range if set
      const labels = [];
      const range = getRangeDates();
      const ytSrc = range ? ytWeekly.filter(d => d._date >= range[0] && d._date <= range[1]) : ytWeekly;
      const wkSrc = range ? wikiWeekly.filter(d => d._date >= range[0] && d._date <= range[1]) : wikiWeekly;
      const ytMap = new Map(ytSrc.map(d=>[d._dateStr, Number(d['Number of Videos'])]));
      const wkMap = new Map(wkSrc.map(d=>[d._dateStr, Number(d._value)]));
      const allKeys = new Set([...ytMap.keys(), ...wkMap.keys()]);
      const sortedKeys = [...allKeys].sort();
      const ytSeries = [];
      const wkSeries = [];
      sortedKeys.forEach(k=>{ labels.push(k); ytSeries.push(ytMap.get(k) ?? 0); wkSeries.push(wkMap.get(k) ?? 0); });
      if (weeklyChart) weeklyChart.destroy();
      weeklyChart = new Chart(weeklyCtx, {
        type: 'line',
        data: {
          labels,
          datasets: [
            { label: 'YouTube: Videos (wöchentlich)', data: ytSeries, borderColor: '#6366f1', backgroundColor: 'rgba(99,102,241,0.2)', tension: 0.2, fill: true },
            { label: 'Wikipedia: Seitenaufrufe (wöchentlich)', data: wkSeries, borderColor: '#22c55e', backgroundColor: 'rgba(34,197,94,0.2)', tension: 0.2, fill: true }
          ]
        },
        options: { scales: { x: { ticks: { color: getAxis() }, grid: { color: getGrid() } }, y: { ticks: { color: getAxis() }, grid: { color: getGrid() } } } }
      });
    }


    function renderAll(){
      renderScatter();
      renderLine();
      renderWeekly();
    }

    function fmtDate(d){
      const pad = (n)=> String(n).padStart(2,'0');
      return `${pad(d.getDate())}.${pad(d.getMonth()+1)}.${d.getFullYear()}`;
    }

    function initFilters(){
      dailySorted = [...daily].sort((a,b)=> Number(a['Published At']) - Number(b['Published At']));
      dateLabels = dailySorted.map(d=> new Date(Number(d['Published At'])));
      const minIndex = 0;
      const maxIndex = dateLabels.length - 1;
      currentRange = [minIndex, maxIndex];

      slider = document.getElementById('date-range-slider');
      lblStart = document.getElementById('range-start');
      lblEnd = document.getElementById('range-end');
      yearSelect = document.getElementById('year-select');
      resetBtn = document.getElementById('reset-filters');

      if (slider && window.noUiSlider){
        if (slider.noUiSlider){ slider.noUiSlider.destroy(); }
        noUiSlider.create(slider, { start: [minIndex, maxIndex], connect: true, step: 1, range: { min: minIndex, max: maxIndex } });
        const updateLabels = (s,e)=>{
          lblStart.textContent = fmtDate(dateLabels[s]);
          lblEnd.textContent = fmtDate(dateLabels[e]);
        };
        updateLabels(minIndex, maxIndex);
        slider.noUiSlider.on('update', (values)=>{
          const s = Math.round(Number(values[0]));
          const e = Math.round(Number(values[1]));
          currentRange = [s,e];
          updateLabels(s,e);
          renderLine();
          renderWeekly();
        });
      }

      // Build year ranges and dropdown
      yearRanges = {};
      dateLabels.forEach((d,i)=>{
        const y = d.getFullYear();
        if (!(y in yearRanges)) yearRanges[y] = [i,i]; else yearRanges[y][1] = i;
      });
      if (yearSelect){
        // remove existing year options except "" (Alle Jahre)
        [...yearSelect.querySelectorAll('option')].filter(o=> o.value !== '').forEach(o=> o.remove());
        Object.keys(yearRanges).forEach(y=>{
          const opt = document.createElement('option');
          opt.value = String(y);
          opt.textContent = String(y);
          yearSelect.appendChild(opt);
        });
        yearSelect.addEventListener('change', ()=>{
          const val = yearSelect.value;
          if (!val){
            if (slider?.noUiSlider){ slider.noUiSlider.set([minIndex, maxIndex]); }
            currentRange = [minIndex, maxIndex];
            renderLine();
            renderWeekly();
          } else {
            const [s,e] = yearRanges[val];
            currentRange = [s,e];
            if (slider?.noUiSlider){ slider.noUiSlider.set([s,e]); }
            renderLine();
            renderWeekly();
          }
        });
      }

      if (resetBtn){
        resetBtn.addEventListener('click', ()=>{
          if (yearSelect) yearSelect.value = '';
          const minIndexR = 0, maxIndexR = dateLabels.length - 1;
          currentRange = [minIndexR, maxIndexR];
          if (slider?.noUiSlider){ slider.noUiSlider.set([minIndexR, maxIndexR]); }
          renderLine();
          renderWeekly();
        });
      }
    }

    Promise.all([
      fetch('/afd_wiki.json').then(r=>r.json()),
      fetch('/afd_yt.json').then(r=>r.json()),
      fetch('/afd_wiki_daily.json').then(r=>r.json()),
      fetch('/afd_yt_daily.json').then(r=>r.json()),
    ]).then(([wikiWeeklyJson, ytWeeklyJson, wikiDailyJson, ytDailyJson]) => {
      // Parse wiki weekly
      wikiWeekly = (Array.isArray(wikiWeeklyJson)? wikiWeeklyJson: []).map(r=>{
        // source has date under empty key "" and value under "Alternative_für_Deutschland"
        const dateStr = (r[""] || r.date || r.Date || r.Datum || '').toString();
        const d = new Date(dateStr);
        return { _date: d, _dateStr: d.toISOString().slice(0,10), _value: Number(r['Alternative_für_Deutschland']||0) };
      }).filter(x=> !isNaN(x._date.getTime()));
      // Parse yt weekly (already with proper keys)
      ytWeekly = (Array.isArray(ytWeeklyJson)? ytWeeklyJson: []).map(r=>{
        const raw = String(r['Published At']||'');
        const iso = raw.includes('T') ? raw : raw.replace(' ', 'T');
        const d = new Date(iso);
        return { _date: d, _dateStr: isNaN(d.getTime()) ? '' : d.toISOString().slice(0,10), 'Number of Videos': Number(r['Number of Videos']||0) };
      }).filter(r=> r._dateStr);

      // Build combined weekly points by aligning dates
      const ytWkMap = new Map(ytWeekly.map(d=>[d._dateStr, d['Number of Videos']]));
      const wkWkMap = new Map(wikiWeekly.map(d=>[d._dateStr, d._value]));
      // Use union of weeks and fill missing values with 0 so we don't drop points
      const wkAllKeys = [...new Set([...ytWkMap.keys(), ...wkWkMap.keys()])].sort();
      combined = wkAllKeys.map(k => ({ 'Number of Videos': ytWkMap.get(k) ?? 0, 'Wikipedia Pageviews': wkWkMap.get(k) ?? 0 }));

      // Parse wiki daily
      wikiDaily = (Array.isArray(wikiDailyJson)? wikiDailyJson: []).map(r=>{
        const dateStr = (r[""] || r.date || '').toString();
        const d = new Date(dateStr);
        return { _date: d, _dateStr: d.toISOString().slice(0,10), _value: Number(r['Alternative_für_Deutschland']||0) };
      }).filter(x=> !isNaN(x._date.getTime()));
      // Parse yt daily
      const ytDaily = (Array.isArray(ytDailyJson)? ytDailyJson: []).map(r=>{
        const raw = String(r['Published At']||'');
        const iso = raw.includes('T') ? raw : raw.replace(' ', 'T');
        const d = new Date(iso);
        return { _date: d, _dateStr: isNaN(d.getTime()) ? '' : d.toISOString().slice(0,10), _value: Number(r['Number of Videos']||0) };
      }).filter(x=> x._dateStr);

      // Build daily combined array expected by charts
      const ytDailyMap = new Map(ytDaily.map(d=>[d._dateStr, d._value]));
      const wkDailyMap = new Map(wikiDaily.map(d=>[d._dateStr, d._value]));
      const dailyKeys = [...new Set([...ytDailyMap.keys(), ...wkDailyMap.keys()])].sort();
      daily = dailyKeys.map(k => ({
        'Published At': new Date(k).getTime(),
        'Number of Videos': ytDailyMap.get(k) ?? 0,
        'Wikipedia Pageviews': wkDailyMap.get(k) ?? 0
      }));

      // Init controls for daily combined series
      initFilters();
      whenChartReady(() => renderAll());
    }).catch(err => {
      console.error('Fehler beim Laden der AfD-Daten', err);
    });
  });
</script>
{% include 'partials/footer.html' %}
</body>
</html>
